{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"getting-started/","title":"Getting Started","text":"<p>This section will guide you through the installation, dependencies, and basic usage of the YouTube DL Scraper package.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>To install YouTube DL Scraper, use the following command:</p> Latest <pre><code>pip install youtube-dl-api\n</code></pre> Alternatively <p>Alternatively, you can install it directly from the source:</p> <pre><code>git clone https://github.com/your-repo/youtube-dl-api.git\ncd youtube-dl-api\npip install .\n</code></pre>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>Ensure the following dependencies are installed:</p> <ul> <li> <p>Python 3.7 or higher</p> </li> <li> <p>FFmpeg (for audio/video processing)</p> </li> </ul> <p>To install FFmpeg:</p> LinuxmacOSWindows <pre><code>sudo apt install ffmpeg  # For Ubuntu/Debian\n</code></pre> <pre><code>brew install ffmpeg  # For macOS\n</code></pre> <pre><code>choco install ffmpeg  # For Windows (using Chocolatey)\n</code></pre> <p>Note</p> <p>You can also download the installer for your Os from here</p>"},{"location":"overview/","title":"Overview","text":"<p>YouTube DL Scraper is a Python  library for scraping YouTube  video/audio streams and metadata. It's lightweight, easy to use, and perfect for integrating YouTube data into your projects.</p> <p>Warning</p> <p>This is the alpha version and the project is still in the testing phase.</p>"},{"location":"overview/#features","title":"Features","text":"<ul> <li>Fetch video metadata such as title, description, and available streams.</li> <li>Filter video/audio streams by resolution, bitrate, or format.</li> <li>Download video/audio streams effortlessly.</li> <li>Modular and extensible for advanced use cases.</li> </ul>"},{"location":"overview/#installation","title":"Installation","text":""},{"location":"overview/#with-pip","title":"Install via pip recommended","text":"<p>YouTube DL Scraper is published as a [Python package] and can be installed with <code>pip</code>, ideally by using a virtual environment<sup>1</sup>. Open up a terminal and install YouTube DL Scraper with:</p> Latest <pre><code>pip install youtube-dl-scraper\n</code></pre> Example Usage <p>Fetch <code>title</code> and download YouTube video:</p> example.py<pre><code>from youtube_dl_scraper import YouTube # (1)!\n\nyoutube = YouTube()\n\n# Scrape video data\nvideo = youtube.scrape_video(\"https://youtu.be/sF9xYtouZjY?si=z6ZWk4raQeHgQDz\")\n\nprint(video.title) # Print the video title (2)\n# Download video\nprint(video.streams.get_highest_resolution().download()) # (3)!\n</code></pre> <ol> <li>Importing scraper from package</li> <li>Output: <code>'Driving The New Fastest Car Ever Made!'</code></li> <li>Output (file path): <code>'driving-the-new-fastest-car-ever-made-720p-30fps.mp4'</code></li> </ol> <ol> <li> <p>A virtual environment in programming (specifically in Python) is an isolated workspace that allows you to manage dependencies, libraries, and tools for a particular project without affecting the global system environment.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/converter/audio_converter/","title":"Reference for <code>youtube_dl_scraper/converter/audio_converter.py</code>","text":""},{"location":"reference/converter/audio_converter/#youtube_dl_scraper.converter.audio_converter.AudioConverter","title":"youtube_dl_scraper.converter.audio_converter.AudioConverter","text":"<pre><code>AudioConverter(input_path: str, output_path: str, audio_codec: Optional[str], bitrate: Optional[str] = None, force_render: bool = False, experimental: bool = True)\n</code></pre> <p>               Bases: <code>BaseConverter</code></p> <p>AudioConverter class provides functionality to convert audio files into different formats by re-encoding or copying the existing audio stream with the specified audio codec.</p> <p>Attributes:</p> Name Type Description <code>input_path</code> <code>str</code> <p>Path to the input audio or video file.</p> <code>output_path</code> <code>str</code> <p>Path to the output audio file.</p> <code>audio_codec</code> <code>str</code> <p>Desired audio codec (e.g., \"aac\", \"mp3\").</p> <code>bitrate</code> <code>Optional[str]</code> <p>Desired audio bitrate (e.g., \"128k\", \"192k\").</p> <code>force_render</code> <code>bool</code> <p>If True, forces re-rendering even if codecs match.</p> <code>experimental</code> <code>bool</code> <p>If True, allow for experimental codec supported by ffmpeg else don't.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input file (audio or video).</p> required <code>output_path</code> <code>str</code> <p>Path to the output audio file.</p> required <code>audio_codec</code> <code>Optional[str]</code> <p>Desired audio codec (e.g., \"aac\", \"mp3\").</p> required <code>bitrate</code> <code>Optional[str]</code> <p>Desired audio bitrate (e.g., \"128k\", \"192k\").</p> <code>None</code> <code>force_render</code> <code>bool</code> <p>If True, force re-rendering even if codecs match.</p> <code>False</code> <code>experimental</code> <code>bool</code> <p>If True, allow for experimental codec supported by ffmpeg else don't.</p> <code>True</code> Source code in <code>youtube_dl_scraper/converter/audio_converter.py</code> <pre><code>def __init__(\n    self,\n    input_path: str,\n    output_path: str,\n    audio_codec: Optional[str],\n    bitrate: Optional[str] = None,\n    force_render: bool = False,\n    experimental: bool = True,\n):\n    \"\"\"\n    Initialize the converter.\n\n    Args:\n        input_path (str): Path to the input file (audio or video).\n        output_path (str): Path to the output audio file.\n        audio_codec (Optional[str]): Desired audio codec (e.g., \"aac\", \"mp3\").\n        bitrate (Optional[str]): Desired audio bitrate (e.g., \"128k\", \"192k\").\n        force_render (bool): If True, force re-rendering even if codecs match.\n        experimental (bool): If True, allow for experimental codec supported by ffmpeg else don't.\n    \"\"\"\n    self.input_path = input_path\n    self.output_path = output_path\n    self.audio_codec = audio_codec\n    self.bitrate = bitrate\n    self.force_render = force_render\n    self.experimental = experimental\n</code></pre>"},{"location":"reference/converter/audio_converter/#youtube_dl_scraper.converter.audio_converter.AudioConverter.convert","title":"convert","text":"<pre><code>convert() -&gt; str\n</code></pre> <p>Perform the conversion.</p> <p>Converts input audio or video file into the desired audio format, with an optional bitrate.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the converted audio file if successful.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input file does not exist or the output file was not created.</p> Source code in <code>youtube_dl_scraper/converter/audio_converter.py</code> <pre><code>def convert(self) -&gt; str:\n    \"\"\"\n    Perform the conversion.\n\n    Converts input audio or video file into the desired audio format, with an optional bitrate.\n\n    Returns:\n        str: Path to the converted audio file if successful.\n\n    Raises:\n        FileNotFoundError: If the input file does not exist or the output file was not created.\n    \"\"\"\n    if not os.path.exists(self.input_path):\n        raise FileNotFoundError(f\"Input file '{self.input_path}' not found.\")\n\n    # Handle output path being \".\"\n    if self.output_path == \".\":\n        base, _ = os.path.splitext(self.input_path)\n        self.output_path = f\"{base}-audio-converted{'-' + self.bitrate if self.bitrate else ''}.{self.get_default_extension()}\"\n\n    if os.path.exists(self.output_path):\n        output_codec = self.get_audio_codec(self.output_path)\n        print(f\"Output Audio Codec: {output_codec}\")\n\n        if output_codec == self.audio_codec:\n            print(\"Output file exists and matches the specified codec.\")\n            return self.output_path\n        else:\n            print(\n                \"Output file exists but does not match the specified codec. Overwriting...\"\n            )\n            os.remove(self.output_path)\n\n    input_codec = self.get_audio_codec(self.input_path)\n    print(f\"Input Audio Codec: {input_codec}\")\n\n    # Extract or convert the audio stream\n    if not self.force_render and input_codec == self.audio_codec:\n        print(\"Codec matches! Copying audio stream without re-rendering...\")\n        (\n            ffmpeg.input(self.input_path)\n            .output(\n                self.output_path,\n                codec=\"copy\",\n                vn=None,\n                strict=(self.experimental and \"experimental\") or None,\n            )\n            .run()\n        )\n    else:\n        print(\n            \"Extracting and/or re-rendering audio with the specified codec and bitrate...\"\n        )\n        ffmpeg_output_options = {\"acodec\": self.audio_codec or \"copy\", \"vn\": None}\n        if self.bitrate:\n            ffmpeg_output_options[\"audio_bitrate\"] = self.bitrate\n\n        (\n            ffmpeg.input(self.input_path)\n            .output(\n                self.output_path,\n                **ffmpeg_output_options,\n                strict=(self.experimental and \"experimental\") or None,\n            )\n            .run()\n        )\n\n    if os.path.exists(self.output_path):\n        print(f\"Audio conversion complete! File saved at: {self.output_path}\")\n        return self.output_path\n    else:\n        raise FileNotFoundError(\"Output file was not created.\")\n</code></pre>"},{"location":"reference/converter/audio_converter/#youtube_dl_scraper.converter.audio_converter.AudioConverter.get_audio_codec","title":"get_audio_codec  <code>staticmethod</code>","text":"<pre><code>get_audio_codec(file_path: str) -&gt; Optional[str]\n</code></pre> <p>Retrieve the audio codec of a file using ffmpeg-python.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file (audio or video).</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The audio codec of the file, or None if no audio stream is found.</p> Source code in <code>youtube_dl_scraper/converter/audio_converter.py</code> <pre><code>@staticmethod\ndef get_audio_codec(file_path: str) -&gt; Optional[str]:\n    \"\"\"\n    Retrieve the audio codec of a file using ffmpeg-python.\n\n    Args:\n        file_path (str): Path to the file (audio or video).\n\n    Returns:\n        Optional[str]: The audio codec of the file, or None if no audio stream is found.\n    \"\"\"\n    probe = ffmpeg.probe(file_path)\n    audio_stream = next(\n        (stream for stream in probe[\"streams\"] if stream[\"codec_type\"] == \"audio\"),\n        None,\n    )\n    return audio_stream[\"codec_name\"] if audio_stream else None\n</code></pre>"},{"location":"reference/converter/audio_converter/#youtube_dl_scraper.converter.audio_converter.AudioConverter.get_default_extension","title":"get_default_extension","text":"<pre><code>get_default_extension() -&gt; str\n</code></pre> <p>Determine the appropriate file extension based on the audio codec.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A suitable file extension (e.g., \".mp3\", \".m4a\").</p> Source code in <code>youtube_dl_scraper/converter/audio_converter.py</code> <pre><code>def get_default_extension(self) -&gt; str:\n    \"\"\"\n    Determine the appropriate file extension based on the audio codec.\n\n    Returns:\n        str: A suitable file extension (e.g., \".mp3\", \".m4a\").\n    \"\"\"\n    codec_to_extension = {\n        \"aac\": \"m4a\",  # AAC is typically stored in M4A\n        \"mp3\": \"mp3\",\n        \"flac\": \"flac\",\n        \"opus\": \"opus\",\n        \"wav\": \"wav\",\n    }\n    return codec_to_extension.get(\n        self.audio_codec, \"m4a\"\n    )  # Default to m4a for unsupported codecs\n</code></pre>"},{"location":"reference/converter/base_converter/","title":"Reference for <code>youtube_dl_scraper/converter/base_converter.py</code>","text":""},{"location":"reference/converter/base_converter/#youtube_dl_scraper.converter.base_converter.BaseConverter","title":"youtube_dl_scraper.converter.base_converter.BaseConverter","text":"<pre><code>BaseConverter(input_path, output_path)\n</code></pre> <p>Base class for converters</p> Source code in <code>youtube_dl_scraper/converter/base_converter.py</code> <pre><code>def __init__(self, input_path, output_path):\n    \"\"\"Intialize setup converter.\"\"\"\n    self.input_path = input_path\n    self.output_path = output_path\n</code></pre>"},{"location":"reference/converter/base_converter/#youtube_dl_scraper.converter.base_converter.BaseConverter.convert","title":"convert","text":"<pre><code>convert()\n</code></pre> <p>Converts media to specified format/codec</p> Source code in <code>youtube_dl_scraper/converter/base_converter.py</code> <pre><code>def convert(self):\n    \"Converts media to specified format/codec\"\n    raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/converter/video_converter/","title":"Reference for <code>youtube_dl_scraper/converter/video_converter.py</code>","text":""},{"location":"reference/converter/video_converter/#youtube_dl_scraper.converter.video_converter.VideoConverter","title":"youtube_dl_scraper.converter.video_converter.VideoConverter","text":"<pre><code>VideoConverter(input_path: str, output_path: str, video_codec: str, audio_codec: Optional[str], force_render: bool = False, experimental: bool = True)\n</code></pre> <p>               Bases: <code>BaseConverter</code></p> <p>VideoConverter class provides functionality to convert video files into different formats by re-encoding or copying the existing streams with specified video and audio codecs.</p> <p>Attributes:</p> Name Type Description <code>input_path</code> <code>str</code> <p>Path to the input video file.</p> <code>output_path</code> <code>str</code> <p>Path to the output video file.</p> <code>video_codec</code> <code>str</code> <p>Desired video codec (e.g., \"h264\", \"hevc\").</p> <code>audio_codec</code> <code>Optional[str]</code> <p>Desired audio codec (e.g., \"aac\", \"mp3\").</p> <code>force_render</code> <code>bool</code> <p>If True, forces re-rendering even if codecs match.</p> <code>experimental</code> <code>bool</code> <p>If True, allow for experimental codec supported by ffmpeg else don't.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input video file.</p> required <code>output_path</code> <code>str</code> <p>Path to the output video file.</p> required <code>video_codec</code> <code>str</code> <p>Desired video codec (e.g., \"h264\", \"hevc\").</p> required <code>audio_codec</code> <code>Optional[str]</code> <p>Desired audio codec (e.g., \"aac\", \"mp3\").</p> required <code>force_render</code> <code>bool</code> <p>If True, force re-rendering even if codecs match.</p> <code>False</code> <code>experimental</code> <code>bool</code> <p>If True, allow for experimental codec supported by ffmpeg else don't.</p> <code>True</code> Source code in <code>youtube_dl_scraper/converter/video_converter.py</code> <pre><code>def __init__(\n    self,\n    input_path: str,\n    output_path: str,\n    video_codec: str,\n    audio_codec: Optional[str],\n    force_render: bool = False,\n    experimental: bool = True,\n):\n    \"\"\"\n    Initialize the converter.\n\n    Args:\n        input_path (str): Path to the input video file.\n        output_path (str): Path to the output video file.\n        video_codec (str): Desired video codec (e.g., \"h264\", \"hevc\").\n        audio_codec (Optional[str]): Desired audio codec (e.g., \"aac\", \"mp3\").\n        force_render (bool): If True, force re-rendering even if codecs match.\n        experimental (bool): If True, allow for experimental codec supported by ffmpeg else don't.\n    \"\"\"\n    self.input_path = input_path\n    self.output_path = output_path\n    self.video_codec = video_codec\n    self.audio_codec = audio_codec\n    self.force_render = force_render\n    self.experimental = experimental\n</code></pre>"},{"location":"reference/converter/video_converter/#youtube_dl_scraper.converter.video_converter.VideoConverter.convert","title":"convert","text":"<pre><code>convert() -&gt; str\n</code></pre> <p>Perform the conversion.</p> <p>Skips re-rendering if the codecs already match, unless force_render is True.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the converted video if successful.</p> Source code in <code>youtube_dl_scraper/converter/video_converter.py</code> <pre><code>def convert(self) -&gt; str:\n    \"\"\"\n    Perform the conversion.\n\n    Skips re-rendering if the codecs already match, unless force_render is True.\n\n    Returns:\n        str: Path to the converted video if successful.\n    \"\"\"\n    if not os.path.exists(self.input_path):\n        raise FileNotFoundError(f\"Input file '{self.input_path}' not found.\")\n\n    # Handle output path being \".\"\n    if self.output_path == \".\":\n        base, ext = os.path.splitext(self.input_path)\n        self.output_path = f\"{base}-converted{ext}\"\n\n    if os.path.exists(self.output_path):\n        output_codecs = self.get_codecs(self.output_path)\n        output_video_codec = output_codecs[\"video\"]\n        output_audio_codec = output_codecs[\"audio\"]\n\n        if output_video_codec == self.video_codec and (\n            output_audio_codec == self.audio_codec or \"aac\"\n        ):\n            print(\"Output file exists and matches specified codecs.\")\n            return self.output_path\n        else:\n            print(\"Output file exists, overwriting output file...\")\n            os.remove(self.output_path)\n\n    codecs = self.get_codecs(self.input_path)\n    input_video_codec = codecs[\"video\"]\n    input_audio_codec = codecs[\"audio\"]\n\n    print(f\"Input Video Codec: {input_video_codec}\")\n    print(f\"Input Audio Codec: {input_audio_codec}\")\n    print(f\"Output Video Codec: {self.video_codec}\")\n    print(f\"Output Audio Codec: {self.audio_codec or 'copy'}\")\n\n    # Check if re-rendering is needed\n    if (\n        not self.force_render\n        and input_video_codec == self.video_codec\n        and input_audio_codec == self.audio_codec\n    ):\n        print(\"Codecs match! Copying streams without re-rendering...\")\n        # Copy streams directly\n        (\n            ffmpeg.input(self.input_path)\n            .output(\n                self.output_path,\n                codec=\"copy\",\n                strict=(self.experimental and \"experimental\") or None,\n            )\n            .run()\n        )\n    else:\n        print(\"Re-rendering with specified codecs...\")\n        # Re-encode with specified codecs\n        (\n            ffmpeg.input(self.input_path)\n            .output(\n                self.output_path,\n                vcodec=self.video_codec or \"copy\",\n                acodec=self.audio_codec or \"copy\",\n                strict=(self.experimental and \"experimental\") or None,\n            )\n            .run()\n        )\n\n    if os.path.exists(self.output_path):\n        print(f\"Video conversion complete! File saved at: {self.output_path}\")\n        return self.output_path\n    else:\n        raise FileNotFoundError(\"Output file was not created.\")\n</code></pre>"},{"location":"reference/converter/video_converter/#youtube_dl_scraper.converter.video_converter.VideoConverter.get_codecs","title":"get_codecs  <code>staticmethod</code>","text":"<pre><code>get_codecs(file_path: str) -&gt; Dict[str, Optional[str]]\n</code></pre> <p>Retrieve the codecs of a file using ffmpeg-python.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the video file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Optional[str]]</code> <p>A dictionary with 'video' and 'audio' keys containing their respective codecs.</p> Source code in <code>youtube_dl_scraper/converter/video_converter.py</code> <pre><code>@staticmethod\ndef get_codecs(file_path: str) -&gt; Dict[str, Optional[str]]:\n    \"\"\"\n    Retrieve the codecs of a file using ffmpeg-python.\n\n    Args:\n        file_path (str): Path to the video file.\n\n    Returns:\n        dict: A dictionary with 'video' and 'audio' keys containing their respective codecs.\n    \"\"\"\n    probe = ffmpeg.probe(file_path)\n    video_stream = next(\n        (stream for stream in probe[\"streams\"] if stream[\"codec_type\"] == \"video\"),\n        None,\n    )\n    audio_stream = next(\n        (stream for stream in probe[\"streams\"] if stream[\"codec_type\"] == \"audio\"),\n        None,\n    )\n\n    return {\n        \"video\": video_stream[\"codec_name\"] if video_stream else None,\n        \"audio\": audio_stream[\"codec_name\"] if audio_stream else None,\n    }\n</code></pre>"},{"location":"reference/core/base_scraper/","title":"Reference for <code>youtube_dl_scraper/core/base_scraper.py</code>","text":""},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper","title":"youtube_dl_scraper.core.base_scraper.BaseScraper","text":"<pre><code>BaseScraper(download_path: str)\n</code></pre> <p>Base class for scrapers</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def __init__(self, download_path: str):\n    self.download_path = download_path\n</code></pre>"},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper.async_scrape","title":"async_scrape  <code>async</code>","text":"<pre><code>async_scrape(url: str)\n</code></pre> <p>Scrapes youtube video data from sites asynchronously</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>async def async_scrape(self, url: str):\n    \"\"\"Scrapes youtube video data from sites asynchronously\"\"\"\n    raise NotImplementedError(\"This method should be overwritten\")\n</code></pre>"},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper.async_scrape_captions","title":"async_scrape_captions  <code>async</code>","text":"<pre><code>async_scrape_captions(url: str)\n</code></pre> <p>Scrape youtube caprions data from site asynchronously</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>async def async_scrape_captions(self, url: str):\n    \"\"\"Scrape youtube caprions data from site asynchronously\"\"\"\n    raise NotImplementedError(\"This method should be overwritten\")\n</code></pre>"},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper.custom_prop","title":"custom_prop","text":"<pre><code>custom_prop(obj, data: str)\n</code></pre> <p>adds custom properties in data to obj</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def custom_prop(self, obj, data: str):\n    \"\"\"adds custom properties in data to obj\"\"\"\n    return obj\n</code></pre>"},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper.scrape","title":"scrape","text":"<pre><code>scrape(url: str)\n</code></pre> <p>Scrape youtube video data from site</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def scrape(self, url: str):\n    \"\"\"Scrape youtube video data from site\"\"\"\n    raise NotImplementedError(\"This method should be overwritten\")\n</code></pre>"},{"location":"reference/core/base_scraper/#youtube_dl_scraper.core.base_scraper.BaseScraper.scrape_captions","title":"scrape_captions","text":"<pre><code>scrape_captions(url: str)\n</code></pre> <p>Scrape youtube caprions data from site</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def scrape_captions(self, url: str):\n    \"\"\"Scrape youtube caprions data from site\"\"\"\n    raise NotImplementedError(\"This method should be overwritten\")\n</code></pre>"},{"location":"reference/core/caption/","title":"Reference for <code>youtube_dl_scraper/core/caption.py</code>","text":""},{"location":"reference/core/caption/#youtube_dl_scraper.core.caption.Caption","title":"youtube_dl_scraper.core.caption.Caption","text":"<pre><code>Caption(caption_data: dict, title: str, download_path: str, translated: bool = False)\n</code></pre> <p>Data class for captions.</p> <p>Parameters:</p> Name Type Description Default <code>caption_data</code> <code>dict</code> <p>The raw caption data, including language code, name, and download URLs.</p> required <code>title</code> <code>str</code> <p>The title of the associated video.</p> required <code>download_path</code> <code>str</code> <p>The directory where captions will be downloaded.</p> required <code>translated</code> <code>bool</code> <p>Whether the caption is translated. Defaults to False.</p> <code>False</code> Source code in <code>youtube_dl_scraper/core/caption.py</code> <pre><code>def __init__(\n    self,\n    caption_data: dict,\n    title: str,\n    download_path: str,\n    translated: bool = False,\n):\n    \"\"\"\n    Initialize the Caption object.\n\n    Args:\n        caption_data (dict): The raw caption data, including language code, name, and download URLs.\n        title (str): The title of the associated video.\n        download_path (str): The directory where captions will be downloaded.\n        translated (bool, optional): Whether the caption is translated. Defaults to False.\n    \"\"\"\n    self.raw_caption_data = caption_data\n    self.title = title\n    self.translated = translated\n    self.lang = caption_data[\"code\"]\n    self.lang_name = caption_data[\"name\"]\n    self.download_dir = download_path\n</code></pre>"},{"location":"reference/core/caption/#youtube_dl_scraper.core.caption.Caption.raw","title":"raw  <code>property</code>","text":"<pre><code>raw: str\n</code></pre> <p>Retrieve the raw caption content in SRT format.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The raw SRT content as a string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the caption does not support the SRT format.</p>"},{"location":"reference/core/caption/#youtube_dl_scraper.core.caption.Caption.srt","title":"srt","text":"<pre><code>srt(content: bool = False, download_path: Optional[str] = None, filename: Optional[str] = None, skip_existent: bool = False) -&gt; Union[str, Path]\n</code></pre> <p>Download or retrieve the caption in SRT format.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>bool</code> <p>If True, return the content as a string; if False, save it to disk. Defaults to False.</p> <code>False</code> <code>download_path</code> <code>Optional[str]</code> <p>The directory to save the file. Defaults to self.download_dir.</p> <code>None</code> <code>filename</code> <code>Optional[str]</code> <p>The name of the file. Extracted from the content-disposition header if not provided.</p> <code>None</code> <code>skip_existent</code> <code>bool</code> <p>If True, skips downloading if a matching file already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, Path]</code> <p>Union[str, Path]: File path if content is False, otherwise the SRT content as a string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the caption does not support the SRT format.</p> <code>FileNotFoundError</code> <p>If the specified file path is invalid.</p> <code>PermissionError</code> <p>If permissions are insufficient.</p> <code>IsADirectoryError</code> <p>If the specified file path is a directory.</p> <code>IOError</code> <p>For I/O-related errors.</p> <code>OSError</code> <p>For OS-level errors.</p> Source code in <code>youtube_dl_scraper/core/caption.py</code> <pre><code>def srt(\n    self,\n    content: bool = False,\n    download_path: Optional[str] = None,\n    filename: Optional[str] = None,\n    skip_existent: bool = False,\n) -&gt; Union[str, Path]:\n    \"\"\"\n    Download or retrieve the caption in SRT format.\n\n    Args:\n        content (bool, optional): If True, return the content as a string; if False, save it to disk. Defaults to False.\n        download_path (Optional[str], optional): The directory to save the file. Defaults to self.download_dir.\n        filename (Optional[str], optional): The name of the file. Extracted from the content-disposition header if not provided.\n        skip_existent (bool, optional): If True, skips downloading if a matching file already exists. Defaults to False.\n\n    Returns:\n        Union[str, Path]: File path if content is False, otherwise the SRT content as a string.\n\n    Raises:\n        NotImplementedError: If the caption does not support the SRT format.\n        FileNotFoundError: If the specified file path is invalid.\n        PermissionError: If permissions are insufficient.\n        IsADirectoryError: If the specified file path is a directory.\n        IOError: For I/O-related errors.\n        OSError: For OS-level errors.\n    \"\"\"\n    dl_link = self.raw_caption_data.get(\"urls\", dict()).get(\"srt\")\n    if not dl_link:\n        raise NotImplementedError(\"caption object don't support the srt format\")\n    response = requests.get(dl_link)\n    response.raise_for_status()\n    if not content:\n        filename = filename or get_filename_from_cd(\n            response.headers.get(\"content-disposition\")\n        )\n        download_path = download_path or self.download_dir\n        filepath = Path(download_path).joinpath(filename)\n\n        if filepath.exists() and skip_existent:\n            if filepath.stat().st_size == len(response.content):\n                print(\"skipping save because file already exists\")\n                return filepath.resolve()\n\n        print(\"Saving file\")\n\n        try:\n            with filepath.open(\"wb\") as file:\n                file.write(response.content)\n            return filepath.resolve()\n        except FileNotFoundError as e:\n            print(\"The specified file was not found.\")\n            raise e\n        except PermissionError as e:\n            print(\"You do not have permission to access this file.\")\n            raise e\n        except IsADirectoryError as e:\n            print(\"Expected a file but found a directory.\")\n            raise e\n        except IOError as e:\n            print(\"An IOError occurred.\")\n            raise e\n        except OSError as e:\n            print(f\"An OS error occurred: {e}\")\n            raise e\n    else:\n        return response.content.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/core/caption/#youtube_dl_scraper.core.caption.Caption.txt","title":"txt","text":"<pre><code>txt(content: bool = False, download_path: Optional[str] = None, filename: Optional[str] = None, skip_existent: bool = False) -&gt; Union[str, Path]\n</code></pre> <p>Download or retrieve the caption in TXT format.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>bool</code> <p>If True, return the content as a string; if False, save it to disk. Defaults to False.</p> <code>False</code> <code>download_path</code> <code>Optional[str]</code> <p>The directory to save the file. Defaults to self.download_dir.</p> <code>None</code> <code>filename</code> <code>Optional[str]</code> <p>The name of the file. Extracted from the content-disposition header if not provided.</p> <code>None</code> <code>skip_existent</code> <code>bool</code> <p>If True, skips downloading if a matching file already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, Path]</code> <p>Union[str, Path]: File path if content is False, otherwise the TXT content as a string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the caption does not support the TXT format.</p> <code>FileNotFoundError</code> <p>If the specified file path is invalid.</p> <code>PermissionError</code> <p>If permissions are insufficient.</p> <code>IsADirectoryError</code> <p>If the specified file path is a directory.</p> <code>IOError</code> <p>For I/O-related errors.</p> <code>OSError</code> <p>For OS-level errors.</p> Source code in <code>youtube_dl_scraper/core/caption.py</code> <pre><code>def txt(\n    self,\n    content: bool = False,\n    download_path: Optional[str] = None,\n    filename: Optional[str] = None,\n    skip_existent: bool = False,\n) -&gt; Union[str, Path]:\n    \"\"\"\n    Download or retrieve the caption in TXT format.\n\n    Args:\n        content (bool, optional): If True, return the content as a string; if False, save it to disk. Defaults to False.\n        download_path (Optional[str], optional): The directory to save the file. Defaults to self.download_dir.\n        filename (Optional[str], optional): The name of the file. Extracted from the content-disposition header if not provided.\n        skip_existent (bool, optional): If True, skips downloading if a matching file already exists. Defaults to False.\n\n    Returns:\n        Union[str, Path]: File path if content is False, otherwise the TXT content as a string.\n\n    Raises:\n        NotImplementedError: If the caption does not support the TXT format.\n        FileNotFoundError: If the specified file path is invalid.\n        PermissionError: If permissions are insufficient.\n        IsADirectoryError: If the specified file path is a directory.\n        IOError: For I/O-related errors.\n        OSError: For OS-level errors.\n    \"\"\"\n    dl_link = self.raw_caption_data.get(\"urls\", dict()).get(\"txt\")\n    if not dl_link:\n        raise NotImplementedError(\"caption object don't support the txt format\")\n    response = requests.get(dl_link)\n    response.raise_for_status()\n    if not content:\n        filename = filename or get_filename_from_cd(\n            response.headers.get(\"content-disposition\")\n        )\n        download_path = download_path or self.download_dir\n        filepath = Path(download_path).joinpath(filename)\n\n        if filepath.exists() and skip_existent:\n            if filepath.stat().st_size == len(response.content):\n                print(\"skipping save because file already exists\")\n                return filepath.resolve()\n            else:\n                print(\"Saving file\")\n\n        try:\n            with filepath.open(\"wb\") as file:\n                file.write(response.content)\n            return filepath.resolve()\n        except FileNotFoundError as e:\n            print(\"The specified file was not found.\")\n            raise e\n        except PermissionError as e:\n            print(\"You do not have permission to access this file.\")\n            raise e\n        except IsADirectoryError as e:\n            print(\"Expected a file but found a directory.\")\n            raise e\n        except IOError as e:\n            print(\"An IOError occurred.\")\n            raise e\n        except OSError as e:\n            print(f\"An OS error occurred: {e}\")\n            raise e\n    else:\n        return response.content.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/core/caption_array/","title":"Reference for <code>youtube_dl_scraper/core/caption_array.py</code>","text":""},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray","title":"youtube_dl_scraper.core.caption_array.CaptionArray","text":"<pre><code>CaptionArray(caption_data: dict, download_path: str)\n</code></pre> <p>A class for managing a collection of captions, including subtitles and translations.</p> <p>Parameters:</p> Name Type Description Default <code>caption_data</code> <code>dict</code> <p>The raw caption data, including subtitles and translations.</p> required <code>download_path</code> <code>str</code> <p>The directory where captions will be downloaded.</p> required Source code in <code>youtube_dl_scraper/core/caption_array.py</code> <pre><code>def __init__(self, caption_data: dict, download_path: str):\n    \"\"\"\n    Initialize the CaptionArray object.\n\n    Args:\n        caption_data (dict): The raw caption data, including subtitles and translations.\n        download_path (str): The directory where captions will be downloaded.\n    \"\"\"\n    self.raw_caption_data = caption_data\n    self.title = caption_data.get(\"title\", \"\")\n    self.duration = caption_data.get(\"duration\")\n    self.thumbnail = caption_data.get(\"thumbnail\")\n    self._subtitles: List[dict] = []\n    self._translations: List[dict] = []\n    self.__subtitles = caption_data.get(\"subtitles\", list())\n    self.__translations = caption_data.get(\"translations\", list())\n    self.download_path = download_path\n</code></pre>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.subtitles","title":"subtitles  <code>property</code>","text":"<pre><code>subtitles: Tuple[dict, ...]\n</code></pre> <p>Get the list of avaliable subtitles.</p> <p>Returns:</p> Type Description <code>Tuple[dict, ...]</code> <p>Tuple[dict, ...]: A tuple of avaliable subtitles.</p>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.translations","title":"translations  <code>property</code>","text":"<pre><code>translations: Tuple[dict, ...]\n</code></pre> <p>Get the list of avaliable translations.</p> <p>Returns:</p> Type Description <code>Tuple[dict, ...]</code> <p>Tuple[dict, ...]: A tuple of avaliable translations.</p>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.get_captions_by_lang_code","title":"get_captions_by_lang_code","text":"<pre><code>get_captions_by_lang_code(lang_code: str) -&gt; Optional[Caption]\n</code></pre> <p>Get a caption filtered by language code.</p> <p>Parameters:</p> Name Type Description Default <code>lang_code</code> <code>str</code> <p>The language code to filter the captions by.</p> required <p>Returns:</p> Type Description <code>Optional[Caption]</code> <p>Optional[Caption]: A Caption object if a matching caption is found, otherwise None.</p> Source code in <code>youtube_dl_scraper/core/caption_array.py</code> <pre><code>def get_captions_by_lang_code(self, lang_code: str) -&gt; Optional[Caption]:\n    \"\"\"\n    Get a caption filtered by language code.\n\n    Args:\n        lang_code (str): The language code to filter the captions by.\n\n    Returns:\n        Optional[Caption]: A Caption object if a matching caption is found, otherwise None.\n    \"\"\"\n    filtered_captions = list(\n        filter(\n            lambda subtitle: lang_code.lower() == subtitle.get(\"code\", \"\").lower(),\n            self.__subtitles,\n        )\n    )\n\n    if filtered_captions:\n        return Caption(filtered_captions[0], self.title, self.download_path)\n    return None\n</code></pre>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.get_captions_by_name","title":"get_captions_by_name","text":"<pre><code>get_captions_by_name(name: str) -&gt; List[Caption]\n</code></pre> <p>Get a list of captions filtered by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to filter the captions by.</p> required <p>Returns:</p> Type Description <code>List[Caption]</code> <p>List[Caption]: A list of Caption objects matching the specified name.</p> Source code in <code>youtube_dl_scraper/core/caption_array.py</code> <pre><code>def get_captions_by_name(self, name: str) -&gt; List[Caption]:\n    \"\"\"\n    Get a list of captions filtered by name.\n\n    Args:\n        name (str): The name to filter the captions by.\n\n    Returns:\n        List[Caption]: A list of Caption objects matching the specified name.\n    \"\"\"\n    filtered_captions = list(\n        filter(\n            lambda subtitle: name.lower() in subtitle.get(\"name\", \"\").lower(),\n            self.__subtitles,\n        )\n    )\n    out = []\n    for caption in filtered_captions:\n        out.append(Caption(caption, self.title, self.download_path))\n\n    return out\n</code></pre>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.get_translated_captions_by_lang_code","title":"get_translated_captions_by_lang_code","text":"<pre><code>get_translated_captions_by_lang_code(lang_code: str) -&gt; Optional[Caption]\n</code></pre> <p>Get a translated caption filtered by language code.</p> <p>Parameters:</p> Name Type Description Default <code>lang_code</code> <code>str</code> <p>The language code to filter the translated captions by.</p> required <p>Returns:</p> Type Description <code>Optional[Caption]</code> <p>Optional[Caption]: A translated Caption object if a matching caption is found, otherwise None.</p> Source code in <code>youtube_dl_scraper/core/caption_array.py</code> <pre><code>def get_translated_captions_by_lang_code(self, lang_code: str) -&gt; Optional[Caption]:\n    \"\"\"\n    Get a translated caption filtered by language code.\n\n    Args:\n        lang_code (str): The language code to filter the translated captions by.\n\n    Returns:\n        Optional[Caption]: A translated Caption object if a matching caption is found, otherwise None.\n    \"\"\"\n    filtered_captions = list(\n        filter(\n            lambda subtitle: lang_code.lower() == subtitle.get(\"code\", \"\").lower(),\n            self.__translations,\n        )\n    )\n\n    if filtered_captions:\n        return Caption(filtered_captions[0], self.title, self.download_path, True)\n    return None\n</code></pre>"},{"location":"reference/core/caption_array/#youtube_dl_scraper.core.caption_array.CaptionArray.get_translated_captions_by_name","title":"get_translated_captions_by_name","text":"<pre><code>get_translated_captions_by_name(name: str) -&gt; List[Caption]\n</code></pre> <p>Get a list of translated captions filtered by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to filter the translated captions by.</p> required <p>Returns:</p> Type Description <code>List[Caption]</code> <p>List[Caption]: A list of translated Caption objects matching the specified name.</p> Source code in <code>youtube_dl_scraper/core/caption_array.py</code> <pre><code>def get_translated_captions_by_name(self, name: str) -&gt; List[Caption]:\n    \"\"\"\n    Get a list of translated captions filtered by name.\n\n    Args:\n        name (str): The name to filter the translated captions by.\n\n    Returns:\n        List[Caption]: A list of translated Caption objects matching the specified name.\n    \"\"\"\n    filtered_captions = list(\n        filter(\n            lambda subtitle: name.lower() in subtitle.get(\"name\", \"\").lower(),\n            self.__translations,\n        )\n    )\n    out = []\n    for caption in filtered_captions:\n        out.append(Caption(caption, self.title, self.download_path, True))\n\n    return out\n</code></pre>"},{"location":"reference/core/exceptions/","title":"Reference for <code>youtube_dl_scraper/core/exceptions.py</code>","text":""},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.YouTubeDLScraperError","title":"youtube_dl_scraper.core.exceptions.YouTubeDLScraperError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions</p>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.ScraperNotFoundError","title":"youtube_dl_scraper.core.exceptions.ScraperNotFoundError","text":"<pre><code>ScraperNotFoundError(scraper_type, scraper_name)\n</code></pre> <p>               Bases: <code>YouTubeDLScraperError</code></p> <p>Raised when a requested scraper is not found.</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, scraper_type, scraper_name):\n    message = f\"No {scraper_type} scraper found with name '{scraper_name}'.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.ScraperExecutionError","title":"youtube_dl_scraper.core.exceptions.ScraperExecutionError","text":"<pre><code>ScraperExecutionError(scraper_name, details='An error occurred during scraping.')\n</code></pre> <p>               Bases: <code>YouTubeDLScraperError</code></p> <p>Raised when a scraper fails during execution.</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, scraper_name, details=\"An error occurred during scraping.\"):\n    message = f\"Error in scraper '{scraper_name}': {details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.VideoNotFoundError","title":"youtube_dl_scraper.core.exceptions.VideoNotFoundError","text":"<pre><code>VideoNotFoundError(scraper_name, details='An error occurred during scraping.')\n</code></pre> <p>               Bases: <code>ScraperExecutionError</code></p> <p>Raised when no captions were found</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, scraper_name, details=\"An error occurred during scraping.\"):\n    message = f\"Error in scraper '{scraper_name}': {details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.CaptionsNotFoundError","title":"youtube_dl_scraper.core.exceptions.CaptionsNotFoundError","text":"<pre><code>CaptionsNotFoundError(scraper_name, details='An error occurred during scraping.')\n</code></pre> <p>               Bases: <code>ScraperExecutionError</code></p> <p>Raised when no captions were found</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, scraper_name, details=\"An error occurred during scraping.\"):\n    message = f\"Error in scraper '{scraper_name}': {details}\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.UnsupportedScraperMethodError","title":"youtube_dl_scraper.core.exceptions.UnsupportedScraperMethodError","text":"<pre><code>UnsupportedScraperMethodError(scraper_name, method_name)\n</code></pre> <p>               Bases: <code>YouTubeDLScraperError</code></p> <p>Raised when a scraper does not support the requested method.</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, scraper_name, method_name):\n    message = (\n        f\"Scraper '{scraper_name}' does not support the method '{method_name}'.\"\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.FileExistsError","title":"youtube_dl_scraper.core.exceptions.FileExistsError","text":"<pre><code>FileExistsError(file_exist, path)\n</code></pre> <p>               Bases: <code>YouTubeDLScraperError</code></p> <p>Reaised when a file exists</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(self, file_exist, path):\n    message = f\"{file_exist} in {path}\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#youtube_dl_scraper.core.exceptions.PlaywrightError","title":"youtube_dl_scraper.core.exceptions.PlaywrightError","text":"<pre><code>PlaywrightError(message, status_code=200, successfull_process=False, error='', output='')\n</code></pre> <p>               Bases: <code>YouTubeDLScraperError</code></p> <p>Raised when Playwright payload execution fails</p> Source code in <code>youtube_dl_scraper/core/exceptions.py</code> <pre><code>def __init__(\n    self, message, status_code=200, successfull_process=False, error=\"\", output=\"\"\n):\n    self.message = f\"Reason: {message} Status code: {status_code}\"\n    self.status_code = status_code\n    self.successfull_process = successfull_process\n    self.error = error or message\n    self.output = output\n\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/core/scraper_manager/","title":"Reference for <code>youtube_dl_scraper/core/scraper_manager.py</code>","text":""},{"location":"reference/core/scraper_manager/#youtube_dl_scraper.core.scraper_manager.ScraperManager","title":"youtube_dl_scraper.core.scraper_manager.ScraperManager","text":"<pre><code>ScraperManager()\n</code></pre> <p>Manages the collection of video and caption scrapers, allowing retrieval and listing of scrapers.</p> <p>Attributes:</p> Name Type Description <code>video_scrapers</code> <code>dict</code> <p>A dictionary of video scrapers.</p> <code>caption_scrapers</code> <code>dict</code> <p>A dictionary of caption scrapers.</p> Source code in <code>youtube_dl_scraper/core/scraper_manager.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the ScraperManager with video and caption scrapers.\n\n    Attributes:\n        video_scrapers (dict): A dictionary of video scrapers.\n        caption_scrapers (dict): A dictionary of caption scrapers.\n    \"\"\"\n    self.video_scrapers = video_scrapers\n    self.caption_scrapers = caption_scrapers\n</code></pre>"},{"location":"reference/core/scraper_manager/#youtube_dl_scraper.core.scraper_manager.ScraperManager.get_scraper_class","title":"get_scraper_class","text":"<pre><code>get_scraper_class(scraper_type: str, name: str) -&gt; BaseScraper\n</code></pre> <p>Retrieve a specific scraper class by its type and name.</p> <p>Parameters:</p> Name Type Description Default <code>scraper_type</code> <code>str</code> <p>The type of scraper, either 'video' or 'caption'.</p> required <code>name</code> <code>str</code> <p>The name of the specific scraper to retrieve.</p> required <p>Returns:</p> Name Type Description <code>BaseScraper</code> <code>BaseScraper</code> <p>The scraper class corresponding to the given type and name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no scraper is found with the provided name and type.</p> Source code in <code>youtube_dl_scraper/core/scraper_manager.py</code> <pre><code>def get_scraper_class(self, scraper_type: str, name: str) -&gt; BaseScraper:\n    \"\"\"\n    Retrieve a specific scraper class by its type and name.\n\n    Args:\n        scraper_type (str): The type of scraper, either 'video' or 'caption'.\n        name (str): The name of the specific scraper to retrieve.\n\n    Returns:\n        BaseScraper: The scraper class corresponding to the given type and name.\n\n    Raises:\n        ValueError: If no scraper is found with the provided name and type.\n    \"\"\"\n    scrapers = getattr(self, f\"{scraper_type.lower()}_scrapers\", {})\n    scraper = scrapers.get(name)\n    if not scraper:\n        raise ValueError(f\"No {scraper_type} scraper found with name '{name}'\")\n    return scraper\n</code></pre>"},{"location":"reference/core/scraper_manager/#youtube_dl_scraper.core.scraper_manager.ScraperManager.list_scrapers","title":"list_scrapers","text":"<pre><code>list_scrapers() -&gt; dict\n</code></pre> <p>List all available scrapers by type.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing lists of available video and caption scrapers under   the keys \"video_scrapers\" and \"caption_scrapers\".</p> Source code in <code>youtube_dl_scraper/core/scraper_manager.py</code> <pre><code>def list_scrapers(self) -&gt; dict:\n    \"\"\"\n    List all available scrapers by type.\n\n    Returns:\n        dict: A dictionary containing lists of available video and caption scrapers under\n              the keys \"video_scrapers\" and \"caption_scrapers\".\n    \"\"\"\n    return {\n        \"video_scrapers\": list(self.video_scrapers.keys()),\n        \"caption_scrapers\": list(self.caption_scrapers.keys()),\n    }\n</code></pre>"},{"location":"reference/core/stream/","title":"Reference for <code>youtube_dl_scraper/core/stream.py</code>","text":""},{"location":"reference/core/stream/#youtube_dl_scraper.core.stream.Stream","title":"youtube_dl_scraper.core.stream.Stream","text":"<pre><code>Stream(stream_data: dict, download_dir: str = '', file_name: str = '')\n</code></pre> <p>A base class for handling streams and downloading files.</p> <p>Attributes:</p> Name Type Description <code>file_name</code> <code>str</code> <p>The name of the file to download.</p> <code>download_dir</code> <code>str</code> <p>The directory where the file will be downloaded.</p> <code>size</code> <code>dict</code> <p>A dictionary containing size details (width and height).</p> <code>get_url</code> <code>Callable</code> <p>A callable to retrieve the stream URL.</p> <p>Methods:</p> Name Description <code>download</code> <p>Downloads the file and handles renaming based on its type.</p> <p>Parameters:</p> Name Type Description Default <code>stream_data</code> <code>dict</code> <p>Metadata about the stream.</p> required <code>download_dir</code> <code>str</code> <p>Directory to download the file. Defaults to \"download\".</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be downloaded. Defaults to \"download\".</p> <code>''</code> Source code in <code>youtube_dl_scraper/core/stream.py</code> <pre><code>def __init__(self, stream_data: dict, download_dir: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Initialize a Stream object.\n\n    Args:\n        stream_data (dict): Metadata about the stream.\n        download_dir (str, optional): Directory to download the file. Defaults to \"download\".\n        file_name (str, optional): Name of the file to be downloaded. Defaults to \"download\".\n    \"\"\"\n    self._stream_data = stream_data\n    self.file_name = file_name or \"download\"\n    self.download_dir = download_dir or \"download\"\n    self._get_url = stream_data.get(\"get_url\")\n    self.get_url_args = stream_data.get(\"args\")\n    self.get_url = lambda: self._get_url(*self.get_url_args)\n    self.size = {\n        \"width\": stream_data.get(\"width\"),\n        \"height\": stream_data.get(\"height\"),\n    }\n</code></pre>"},{"location":"reference/core/stream/#youtube_dl_scraper.core.stream.Stream.download","title":"download","text":"<pre><code>download(file_name: str = '', skip_existent: bool = False, error_on_existent: bool = False, download_dir: str = '', on_complete: Optional[Callable[[str], None]] = None) -&gt; str\n</code></pre> <p>Download the stream and optionally rename it based on its type.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file to be downloaded. Defaults to the initialized file name.</p> <code>''</code> <code>skip_existent</code> <code>bool</code> <p>Skip download if the file already exists. Defaults to False.</p> <code>False</code> <code>error_on_existent</code> <code>bool</code> <p>Raise an error if the file already exists. Defaults to False.</p> <code>False</code> <code>download_dir</code> <code>str</code> <p>Directory to download the file. Defaults to the initialized directory.</p> <code>''</code> <code>on_complete</code> <code>Callable</code> <p>A callback function to run after download. Receives the file path as an argument.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the downloaded file.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file exists and <code>error_on_existent</code> is True.</p> <code>RuntimeError</code> <p>If the download fails.</p> Source code in <code>youtube_dl_scraper/core/stream.py</code> <pre><code>def download(\n    self,\n    file_name: str = \"\",\n    skip_existent: bool = False,\n    error_on_existent: bool = False,\n    download_dir: str = \"\",\n    on_complete: Optional[Callable[[str], None]] = None,\n) -&gt; str:\n    \"\"\"\n    Download the stream and optionally rename it based on its type.\n\n    Args:\n        file_name (str, optional): Name of the file to be downloaded. Defaults to the initialized file name.\n        skip_existent (bool, optional): Skip download if the file already exists. Defaults to False.\n        error_on_existent (bool, optional): Raise an error if the file already exists. Defaults to False.\n        download_dir (str, optional): Directory to download the file. Defaults to the initialized directory.\n        on_complete (Callable, optional): A callback function to run after download. Receives the file path as an argument.\n\n    Returns:\n        str: The path to the downloaded file.\n\n    Raises:\n        FileExistsError: If the file exists and `error_on_existent` is True.\n        RuntimeError: If the download fails.\n    \"\"\"\n    file_name = file_name or self.file_name\n    download_path = download_dir or self.download_dir\n    path = Path(download_path)\n    path.mkdir(parents=True, exist_ok=True)\n    file_path = path / file_name\n\n    if full_name := file_exists(file_name, path):\n        if skip_existent:\n            print(\"File exists\")\n            return full_name\n        if error_on_existent:\n            raise FileExistsError(full_name, path)\n\n    try:\n        with requests.get(self.get_url(), stream=True) as response:\n            response.raise_for_status()\n            total_size = int(response.headers.get(\"content-length\", 0))\n            with file_path.open(\"wb\") as file, tqdm(\n                desc=f\"Downloading {file_name}\",\n                total=total_size if total_size &gt; 0 else None,\n                unit=\"B\",\n                unit_scale=True,\n                unit_divisor=1024,\n                ncols=80,\n            ) as progress_bar:\n                for chunk in response.iter_content(chunk_size=1024):\n                    if chunk:\n                        file.write(chunk)\n                        progress_bar.update(len(chunk))\n\n            print(f\"Download completed: {file_name}\")\n            with file_path.open(\"rb\") as file:\n                file_type = fleep.get(file.read(128))\n                if file_type:\n                    print(\"Renaming file\")\n                    extension = file_type.extension[0]\n                    new_file_path = file_path.with_suffix(\".\" + extension)\n                    file_path.rename(new_file_path)\n                    if on_complete:\n                        on_complete(new_file_path)\n                    return str(new_file_path)\n            if on_complete:\n                on_complete(file_path)\n            return str(file_path)\n\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Failed to download {file_name}: {e}\") from e\n    except Exception as e:\n        raise RuntimeError(f\"An unexpected error occurred: {e}\") from e\n</code></pre>"},{"location":"reference/core/stream/#youtube_dl_scraper.core.stream.VideoStream","title":"youtube_dl_scraper.core.stream.VideoStream","text":"<pre><code>VideoStream(stream_data: dict, download_path: str = '', file_name: str = '')\n</code></pre> <p>               Bases: <code>Stream</code></p> <p>A class for handling video streams.</p> <p>Attributes:</p> Name Type Description <code>resolution_label</code> <code>str</code> <p>The resolution label of the video (e.g., \"1080p\").</p> <code>resolution_value</code> <code>str</code> <p>The numeric resolution quality.</p> <code>has_audio</code> <code>bool</code> <p>Indicates if the video has audio.</p> <code>frame_rate</code> <code>int</code> <p>The frame rate of the video.</p> <code>is_hdr</code> <code>bool</code> <p>Indicates if the video supports HDR.</p> <p>Parameters:</p> Name Type Description Default <code>stream_data</code> <code>dict</code> <p>Metadata about the video stream.</p> required <code>download_path</code> <code>str</code> <p>Directory to download the file. Defaults to \"\".</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be downloaded. Defaults to \"\".</p> <code>''</code> Source code in <code>youtube_dl_scraper/core/stream.py</code> <pre><code>def __init__(self, stream_data: dict, download_path: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Initialize a VideoStream object.\n\n    Args:\n        stream_data (dict): Metadata about the video stream.\n        download_path (str, optional): Directory to download the file. Defaults to \"\".\n        file_name (str, optional): Name of the file to be downloaded. Defaults to \"\".\n    \"\"\"\n    super().__init__(stream_data, download_path, file_name)\n    self.resolution_label = stream_data.get(\"label\")\n    self.resolution = self.resolution_label  # alias for resolution_label\n    self.resolution_value = stream_data.get(\"quality\")\n    self.has_audio = stream_data.get(\"has_audio\", True)\n    self.frame_rate = stream_data.get(\"frame_rate\", 30)\n    self.is_hdr = stream_data.get(\"hdr\", False)\n    self.fps = self.frame_rate\n    self.file_name += f\"-{self.resolution_label}-{self.frame_rate}fps{'-HDR' if self.is_hdr else ''}{'-noaud' if not self.has_audio else ''}\"\n</code></pre>"},{"location":"reference/core/stream/#youtube_dl_scraper.core.stream.AudioStream","title":"youtube_dl_scraper.core.stream.AudioStream","text":"<pre><code>AudioStream(stream_data: dict, download_path: str = '', file_name: str = '')\n</code></pre> <p>               Bases: <code>Stream</code></p> <p>A class for handling audio streams.</p> <p>Attributes:</p> Name Type Description <code>abr_label</code> <code>str</code> <p>The audio bitrate label (e.g., \"128kbps\").</p> <code>abr</code> <code>str</code> <p>The numeric audio quality (alias for bitrate).</p> <p>Parameters:</p> Name Type Description Default <code>stream_data</code> <code>dict</code> <p>Metadata about the audio stream.</p> required <code>download_path</code> <code>str</code> <p>Directory to download the file. Defaults to \"\".</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be downloaded. Defaults to \"\".</p> <code>''</code> Source code in <code>youtube_dl_scraper/core/stream.py</code> <pre><code>def __init__(self, stream_data: dict, download_path: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Initialize an AudioStream object.\n\n    Args:\n        stream_data (dict): Metadata about the audio stream.\n        download_path (str, optional): Directory to download the file. Defaults to \"\".\n        file_name (str, optional): Name of the file to be downloaded. Defaults to \"\".\n    \"\"\"\n    super().__init__(stream_data, download_path, file_name)\n    self.abr_label = stream_data.get(\"label\")\n    self.abr = stream_data.get(\"quality\")  # alias for quality\n    self.file_name += f\"-{self.abr_label}\"\n</code></pre>"},{"location":"reference/core/stream/#youtube_dl_scraper.core.stream.file_exists","title":"youtube_dl_scraper.core.stream.file_exists","text":"<pre><code>file_exists(filename: str, directory: Union[str, Path]) -&gt; Optional[str]\n</code></pre> <p>Check if a file with the given name (without extension) exists in the directory.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The stem (name without extension) of the file to search for.</p> required <code>directory</code> <code>Union[str, Path]</code> <p>The path to the directory to search in. Can be a string or a Path object.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The full path to the file if it exists, otherwise None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided directory path is invalid or does not exist.</p> Source code in <code>youtube_dl_scraper/core/stream.py</code> <pre><code>def file_exists(filename: str, directory: Union[str, Path]) -&gt; Optional[str]:\n    \"\"\"\n    Check if a file with the given name (without extension) exists in the directory.\n\n    Args:\n        filename (str): The stem (name without extension) of the file to search for.\n        directory (Union[str, Path]): The path to the directory to search in. Can be a string or a Path object.\n\n    Returns:\n        Optional[str]: The full path to the file if it exists, otherwise None.\n\n    Raises:\n        ValueError: If the provided directory path is invalid or does not exist.\n    \"\"\"\n    dir_path = Path(directory)\n\n    if not dir_path.is_dir():\n        raise ValueError(f\"The provided path '{directory}' is not a valid directory.\")\n\n    for file in dir_path.iterdir():\n        if file.is_file() and file.stem == filename:\n            return str(file)\n\n    return None\n</code></pre>"},{"location":"reference/core/stream_array/","title":"Reference for <code>youtube_dl_scraper/core/stream_array.py</code>","text":""},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray","title":"youtube_dl_scraper.core.stream_array.StreamArray","text":"<pre><code>StreamArray(**kwargs: Union[List[Stream], Dict[str, Union[Callable, List[Stream]]]])\n</code></pre> <p>A utility class to manage and manipulate a collection of video and audio streams.</p> <p>Parameters:</p> Name Type Description Default <code>streams</code> <code>List[Stream]</code> <p>A list of initial streams to add.</p> required <code>video_api</code> <code>Callable</code> <p>A callable for video stream APIs (reserved for future use).</p> required <code>audio_api</code> <code>Callable</code> <p>A callable for audio stream APIs (reserved for future use).</p> required Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __init__(\n    self, **kwargs: Union[List[Stream], Dict[str, Union[Callable, List[Stream]]]]\n):\n    \"\"\"\n    Initialize the StreamArray object.\n\n    Args:\n        streams (List[Stream], optional): A list of initial streams to add.\n        video_api (Callable, optional): A callable for video stream APIs (reserved for future use).\n        audio_api (Callable, optional): A callable for audio stream APIs (reserved for future use).\n    \"\"\"\n    self._streams = []\n    self._resolutions = []\n\n    if kwargs.get(\"streams\"):\n        self._streams.extend(kwargs[\"streams\"])\n\n    # TODO: use the api_functions to get custom streams\n    self._vid_stream_api = kwargs.get(\"video_api\")\n    self._aud_stream_api = kwargs.get(\"audio_api\")\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.available_qualities","title":"available_qualities  <code>property</code>","text":"<pre><code>available_qualities: dict[str, tuple[int, ...]]\n</code></pre> <p>Get available video and audio qualities.</p> <p>Returns:</p> Type Description <code>dict[str, tuple[int, ...]]</code> <p>dict[str, tuple[int, ...]]: A dictionary containing video resolutions and audio bitrates.</p>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.bitrates","title":"bitrates  <code>property</code>","text":"<pre><code>bitrates: tuple[int, ...]\n</code></pre> <p>Get all unique audio bitrates in the stream collection.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>tuple[int, ...]: Tuple of audio bitrates.</p>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.frame_rates","title":"frame_rates  <code>property</code>","text":"<pre><code>frame_rates: tuple[int, ...]\n</code></pre> <p>Get all unique frame rates from video streams.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>tuple[int, ...]: Tuple of frame rates.</p>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.resolutions","title":"resolutions  <code>property</code>","text":"<pre><code>resolutions: tuple[int, ...]\n</code></pre> <p>Get all unique video resolutions in the stream collection.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>tuple[int, ...]: Tuple of video resolutions.</p>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.streams","title":"streams  <code>property</code>","text":"<pre><code>streams: tuple[Stream, ...]\n</code></pre> <p>Return all streams, sorted by resolution for videos and bitrate for audio.</p> <p>Returns:</p> Type Description <code>tuple[Stream, ...]</code> <p>tuple[Stream, ...]: Sorted tuple of streams.</p>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; Stream\n</code></pre> <p>Access a stream by its index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the stream.</p> required <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>The stream at the given index.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Stream:\n    \"\"\"\n    Access a stream by its index.\n\n    Args:\n        index (int): The index of the stream.\n\n    Returns:\n        Stream: The stream at the given index.\n    \"\"\"\n    try:\n        return self.streams[index]\n    except IndexError:\n        raise IndexError(f\"No stream found at index: {index}\")\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Self\n</code></pre> <p>Initialize iteration over the streams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The StreamArray object.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __iter__(self) -&gt; Self:\n    \"\"\"\n    Initialize iteration over the streams.\n\n    Returns:\n        Self: The StreamArray object.\n    \"\"\"\n    self.i = 0\n    return self\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get the number of streams.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of streams.\n\n    Returns:\n        int: The number of streams.\n    \"\"\"\n    return len(self.streams)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Stream\n</code></pre> <p>Get the next stream during iteration.</p> <p>Returns:</p> Name Type Description <code>Stream</code> <code>Stream</code> <p>The next stream.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If no more streams are available.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __next__(self) -&gt; Stream:\n    \"\"\"\n    Get the next stream during iteration.\n\n    Returns:\n        Stream: The next stream.\n\n    Raises:\n        StopIteration: If no more streams are available.\n    \"\"\"\n    if self.i &lt; len(self.streams):\n        item = self.streams[self.i]\n        self.i += 1\n        return item\n    else:\n        raise StopIteration\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Get a string representation of the streams.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Get a string representation of the streams.\n\n    Returns:\n        str: String representation of the streams.\n    \"\"\"\n    return str(self.streams)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.add_stream","title":"add_stream","text":"<pre><code>add_stream(*streams: Stream) -&gt; None\n</code></pre> <p>Add one or more streams to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*streams</code> <code>Stream</code> <p>Streams to add.</p> <code>()</code> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def add_stream(self, *streams: Stream) -&gt; None:\n    \"\"\"\n    Add one or more streams to the collection.\n\n    Args:\n        *streams (Stream): Streams to add.\n    \"\"\"\n    self._streams.extend(streams)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.filter","title":"filter","text":"<pre><code>filter(**kwargs: Union[str, int, bool]) -&gt; Self\n</code></pre> <p>Filter streams based on attributes.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Union[str, int, bool]</code> <p>Attribute-value pairs to filter by.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A StreamArray with the filtered streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def filter(self, **kwargs: Union[str, int, bool]) -&gt; Self:\n    \"\"\"\n    Filter streams based on attributes.\n\n    Args:\n        **kwargs (Union[str, int, bool]): Attribute-value pairs to filter by.\n\n    Returns:\n        Self: A StreamArray with the filtered streams.\n    \"\"\"\n    reverse = kwargs.pop(\"reverse\", None)\n    if reverse is not None and not isinstance(reverse, bool):\n        raise ValueError(\"Reverse keyword argument must be of type bool\")\n\n    filtered = [\n        stream\n        for stream in self.streams\n        if all(getattr(stream, key, None) == value for key, value in kwargs.items())\n    ]\n    return StreamArray(streams=filtered)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.first","title":"first","text":"<pre><code>first() -&gt; Optional[Stream]\n</code></pre> <p>Get the first stream in the collection.</p> <p>Returns:</p> Type Description <code>Optional[Stream]</code> <p>Optional[Stream]: The first stream, or None if empty.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def first(self) -&gt; Optional[Stream]:\n    \"\"\"\n    Get the first stream in the collection.\n\n    Returns:\n        Optional[Stream]: The first stream, or None if empty.\n    \"\"\"\n    if self.streams:\n        return self.streams[0]\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.get_audio_streams","title":"get_audio_streams","text":"<pre><code>get_audio_streams() -&gt; Self\n</code></pre> <p>Get a new StreamArray containing only audio streams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A StreamArray with audio streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def get_audio_streams(self) -&gt; Self:\n    \"\"\"\n    Get a new StreamArray containing only audio streams.\n\n    Returns:\n        Self: A StreamArray with audio streams.\n    \"\"\"\n    audio_streams = self._get_audio()\n    return StreamArray(streams=audio_streams)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.get_highest_bitrate","title":"get_highest_bitrate","text":"<pre><code>get_highest_bitrate() -&gt; Optional[AudioStream]\n</code></pre> <p>Get the audio stream with the highest bitrate.</p> <p>Returns:</p> Type Description <code>Optional[AudioStream]</code> <p>Optional[AudioStream]: The highest bitrate audio stream.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def get_highest_bitrate(self) -&gt; Optional[AudioStream]:\n    \"\"\"\n    Get the audio stream with the highest bitrate.\n\n    Returns:\n        Optional[AudioStream]: The highest bitrate audio stream.\n    \"\"\"\n    ordered_by_abr = self._get_audio()\n    if ordered_by_abr:\n        return ordered_by_abr[0]\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.get_highest_resolution","title":"get_highest_resolution","text":"<pre><code>get_highest_resolution() -&gt; Optional[VideoStream]\n</code></pre> <p>Get the video stream with the highest resolution.</p> <p>Returns:</p> Type Description <code>Optional[VideoStream]</code> <p>Optional[VideoStream]: The highest resolution video stream.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def get_highest_resolution(self) -&gt; Optional[VideoStream]:\n    \"\"\"\n    Get the video stream with the highest resolution.\n\n    Returns:\n        Optional[VideoStream]: The highest resolution video stream.\n    \"\"\"\n    video_streams = self._get_video()\n    if video_streams:\n        return video_streams[0]\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.get_video_streams","title":"get_video_streams","text":"<pre><code>get_video_streams() -&gt; Self\n</code></pre> <p>Get a new StreamArray containing only video streams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A StreamArray with video streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def get_video_streams(self) -&gt; Self:\n    \"\"\"\n    Get a new StreamArray containing only video streams.\n\n    Returns:\n        Self: A StreamArray with video streams.\n    \"\"\"\n    video_streams = self._get_video()\n    return StreamArray(streams=video_streams)\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.last","title":"last","text":"<pre><code>last() -&gt; Optional[Stream]\n</code></pre> <p>Get the last stream in the collection.</p> <p>Returns:</p> Type Description <code>Optional[Stream]</code> <p>Optional[Stream]: The last stream, or None if empty.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def last(self) -&gt; Optional[Stream]:\n    \"\"\"\n    Get the last stream in the collection.\n\n    Returns:\n        Optional[Stream]: The last stream, or None if empty.\n    \"\"\"\n    if self.streams:\n        return self.streams[-1]\n</code></pre>"},{"location":"reference/core/stream_array/#youtube_dl_scraper.core.stream_array.StreamArray.order_by","title":"order_by","text":"<pre><code>order_by(key: str, reverse: bool = False) -&gt; Self\n</code></pre> <p>Order streams by a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute to order by.</p> required <code>reverse</code> <code>bool</code> <p>Whether to reverse the order.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A StreamArray with ordered streams.</p> Source code in <code>youtube_dl_scraper/core/stream_array.py</code> <pre><code>def order_by(self, key: str, reverse: bool = False) -&gt; Self:\n    \"\"\"\n    Order streams by a specific attribute.\n\n    Args:\n        key (str): The attribute to order by.\n        reverse (bool): Whether to reverse the order.\n\n    Returns:\n        Self: A StreamArray with ordered streams.\n    \"\"\"\n    if not all(hasattr(stream, key) for stream in self.streams):\n        raise ValueError(f\"Key '{key}' not found in all streams.\")\n    return StreamArray(\n        streams=sorted(\n            self.streams,\n            key=lambda stream: getattr(stream, key),\n            reverse=(not reverse),\n        )\n    )\n</code></pre>"},{"location":"reference/core/video/","title":"Reference for <code>youtube_dl_scraper/core/video.py</code>","text":""},{"location":"reference/core/video/#youtube_dl_scraper.core.video.Video","title":"youtube_dl_scraper.core.video.Video","text":"<pre><code>Video(video_data: dict, download_path: str)\n</code></pre> <p>Data class representing a video with streams and captions.</p> <p>Parameters:</p> Name Type Description Default <code>video_data</code> <code>dict</code> <p>A dictionary containing video metadata such as ID, title, etc.</p> required <code>download_path</code> <code>str</code> <p>The directory path where the video and its streams will be saved.</p> required Source code in <code>youtube_dl_scraper/core/video.py</code> <pre><code>def __init__(self, video_data: dict, download_path: str):\n    \"\"\"\n    Initialize the Video object with data and set up basic properties.\n\n    Args:\n        video_data (dict): A dictionary containing video metadata such as ID, title, etc.\n        download_path (str): The directory path where the video and its streams will be saved.\n    \"\"\"\n    self.raw_video_data = video_data\n    self.download_path = download_path\n    self.id = video_data.get(\"id\")\n    self.title = video_data.get(\"title\")\n    self.title_slug = video_data.get(\"title_slug\") or title_to_slug(self.title)\n    self.watch_url = video_data.get(\"watch_url\")\n    self.duration = video_data.get(\"duration\")\n    self.formatted_duration = video_data.get(\n        \"formatted_duration\"\n    ) or format_duration(self.duration)\n    self.fduration = self.formatted_duration  # short hand to formatted_duration\n    self.thumbnail = video_data.get(\"thumbnail\")\n    self._get_captions = None\n</code></pre>"},{"location":"reference/core/video/#youtube_dl_scraper.core.video.Video.captions","title":"captions  <code>property</code>","text":"<pre><code>captions: CaptionArray\n</code></pre> <p>Property that retrieves the captions for the video.</p> <p>Returns:</p> Name Type Description <code>CaptionArray</code> <code>CaptionArray</code> <p>The captions for the video.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If captions are not available.</p>"},{"location":"reference/core/video/#youtube_dl_scraper.core.video.Video.streams","title":"streams  <code>property</code>","text":"<pre><code>streams: StreamArray\n</code></pre> <p>Property that retrieves the streams for the video.</p> <p>Returns:</p> Name Type Description <code>StreamArray</code> <code>StreamArray</code> <p>The parsed video and audio streams.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the \"streams\" key is missing in the raw video data.</p>"},{"location":"reference/core/video/#youtube_dl_scraper.core.video.Video.parse_streams","title":"parse_streams","text":"<pre><code>parse_streams(streams: dict) -&gt; StreamArray\n</code></pre> <p>Parse video and audio streams from the given stream data.</p> <p>Parameters:</p> Name Type Description Default <code>streams</code> <code>dict</code> <p>A dictionary containing stream data with keys 'video' and 'audio'.</p> required <p>Returns:</p> Name Type Description <code>StreamArray</code> <code>StreamArray</code> <p>An object containing parsed video and audio streams.</p> Source code in <code>youtube_dl_scraper/core/video.py</code> <pre><code>def parse_streams(self, streams: dict) -&gt; StreamArray:\n    \"\"\"\n    Parse video and audio streams from the given stream data.\n\n    Args:\n        streams (dict): A dictionary containing stream data with keys 'video' and 'audio'.\n\n    Returns:\n        StreamArray: An object containing parsed video and audio streams.\n    \"\"\"\n    video_streams = streams.get(\"video\", [])\n    video_api = streams.get(\"video_api\", {})\n    audio_streams = streams.get(\"audio\", [])\n    audio_api = streams.get(\"audio_api\", {})\n\n    streams = StreamArray(video_api=video_api, audio_api=audio_api)\n\n    # Adding video streams\n    for stream in video_streams:\n        vid = VideoStream(\n            stream, file_name=self.title_slug, download_path=self.download_path\n        )\n        streams.add_stream(vid)\n\n    # Adding audio streams\n    for stream in audio_streams:\n        aud = AudioStream(\n            stream, file_name=self.title_slug, download_path=self.download_path\n        )\n        streams.add_stream(aud)\n\n    return streams\n</code></pre>"},{"location":"reference/core/youtube/","title":"Reference for <code>youtube_dl_scraper/core/youtube.py</code>","text":""},{"location":"reference/core/youtube/#youtube_dl_scraper.core.youtube.YouTube","title":"youtube_dl_scraper.core.youtube.YouTube","text":"<pre><code>YouTube(video_scraper_name: Optional[str] = 'savetube', caption_scraper_name: Optional[str] = 'downsub', download_path: Optional[str] = 'downloads')\n</code></pre> <p>A class for scraping YouTube videos and captions using specified scrapers.</p> <p>Parameters:</p> Name Type Description Default <code>video_scraper_name</code> <code>Optional[str]</code> <p>The name of the video scraper (default is \"savetube\").</p> <code>'savetube'</code> <code>caption_scraper_name</code> <code>Optional[str]</code> <p>The name of the caption scraper (default is \"downsub\").</p> <code>'downsub'</code> <code>download_path</code> <code>Optional[str]</code> <p>The directory path where videos and captions will be saved (default is \"downloads\").</p> <code>'downloads'</code> Source code in <code>youtube_dl_scraper/core/youtube.py</code> <pre><code>def __init__(\n    self,\n    video_scraper_name: Optional[str] = \"savetube\",\n    caption_scraper_name: Optional[str] = \"downsub\",\n    download_path: Optional[str] = \"downloads\",\n):\n    \"\"\"\n    Initialize the YouTube scraper with the specified video and caption scrapers.\n\n    Args:\n        video_scraper_name (Optional[str]): The name of the video scraper (default is \"savetube\").\n        caption_scraper_name (Optional[str]): The name of the caption scraper (default is \"downsub\").\n        download_path (Optional[str]): The directory path where videos and captions will be saved (default is \"downloads\").\n    \"\"\"\n    from . import Manager\n\n    self.manager = Manager\n    self.download_path = download_path or \"/downloads\"\n\n    # Initialize video scraper\n    video_scraper_class = self.manager.get_scraper_class(\n        \"video\", video_scraper_name\n    )\n    self.video_scraper = video_scraper_class(self.download_path)\n    self.video_scraper_name = video_scraper_name\n\n    # Initialize caption scraper\n    caption_scraper_class = self.manager.get_scraper_class(\n        \"caption\", caption_scraper_name\n    )\n    self.caption_scraper = caption_scraper_class(self.download_path)\n    self.caption_scraper_name = caption_scraper_name\n</code></pre>"},{"location":"reference/core/youtube/#youtube_dl_scraper.core.youtube.YouTube.async_scrape_captions","title":"async_scrape_captions  <code>async</code>","text":"<pre><code>async_scrape_captions(url: str) -&gt; CaptionArray\n</code></pre> <p>Asynchronously scrape captions from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the video for which to scrape captions.</p> required <p>Returns:</p> Name Type Description <code>CaptionArray</code> <code>CaptionArray</code> <p>A CaptionArray object containing the scraped captions.</p> <p>Raises:</p> Type Description <code>ScraperExecutionError</code> <p>If an error occurs while scraping captions.</p> Source code in <code>youtube_dl_scraper/core/youtube.py</code> <pre><code>async def async_scrape_captions(self, url: str) -&gt; CaptionArray:\n    \"\"\"\n    Asynchronously scrape captions from the given URL.\n\n    Args:\n        url (str): The URL of the video for which to scrape captions.\n\n    Returns:\n        CaptionArray: A CaptionArray object containing the scraped captions.\n\n    Raises:\n        ScraperExecutionError: If an error occurs while scraping captions.\n    \"\"\"\n    try:\n        caption_data = await self.caption_scraper.async_scrape(url)\n        captions = CaptionArray(caption_data, self.download_path)\n        captions = self.caption_scraper.custom_prop(\n            captions, caption_data\n        )  # add custom properties\n        return captions\n    except Exception as e:\n        raise ScraperExecutionError(self.caption_scraper_name, str(e))\n</code></pre>"},{"location":"reference/core/youtube/#youtube_dl_scraper.core.youtube.YouTube.async_scrape_video","title":"async_scrape_video  <code>async</code>","text":"<pre><code>async_scrape_video(url: str) -&gt; Video\n</code></pre> <p>Asynchronously scrape video data from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the video to scrape.</p> required <p>Returns:</p> Name Type Description <code>Video</code> <code>Video</code> <p>A Video object containing the scraped video data.</p> <p>Raises:</p> Type Description <code>ScraperExecutionError</code> <p>If an error occurs while scraping the video.</p> Source code in <code>youtube_dl_scraper/core/youtube.py</code> <pre><code>async def async_scrape_video(self, url: str) -&gt; Video:\n    \"\"\"\n    Asynchronously scrape video data from the given URL.\n\n    Args:\n        url (str): The URL of the video to scrape.\n\n    Returns:\n        Video: A Video object containing the scraped video data.\n\n    Raises:\n        ScraperExecutionError: If an error occurs while scraping the video.\n    \"\"\"\n    try:\n        video_data = await self.video_scraper.async_scrape(url)\n        vid = Video(video_data, self.download_path)\n        vid = self.video_scraper.custom_prop(\n            vid, video_data\n        )  # add custom properties\n        return vid\n    except Exception as e:\n        raise ScraperExecutionError(self.video_scraper_name, str(e))\n</code></pre>"},{"location":"reference/core/youtube/#youtube_dl_scraper.core.youtube.YouTube.scrape_captions","title":"scrape_captions","text":"<pre><code>scrape_captions(url: str) -&gt; CaptionArray\n</code></pre> <p>Synchronously scrape captions from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the video for which to scrape captions.</p> required <p>Returns:</p> Name Type Description <code>CaptionArray</code> <code>CaptionArray</code> <p>A CaptionArray object containing the scraped captions.</p> <p>Raises:</p> Type Description <code>ScraperExecutionError</code> <p>If an error occurs while scraping captions.</p> Source code in <code>youtube_dl_scraper/core/youtube.py</code> <pre><code>def scrape_captions(self, url: str) -&gt; CaptionArray:\n    \"\"\"\n    Synchronously scrape captions from the given URL.\n\n    Args:\n        url (str): The URL of the video for which to scrape captions.\n\n    Returns:\n        CaptionArray: A CaptionArray object containing the scraped captions.\n\n    Raises:\n        ScraperExecutionError: If an error occurs while scraping captions.\n    \"\"\"\n    try:\n        caption_data = self.caption_scraper.scrape_captions(url)\n        captions = CaptionArray(caption_data, self.download_path)\n        captions = self.caption_scraper.custom_prop(\n            captions, caption_data\n        )  # add custom properties\n        return captions\n    except Exception as e:\n        raise ScraperExecutionError(self.caption_scraper_name, str(e))\n</code></pre>"},{"location":"reference/core/youtube/#youtube_dl_scraper.core.youtube.YouTube.scrape_video","title":"scrape_video","text":"<pre><code>scrape_video(url: str) -&gt; Video\n</code></pre> <p>Synchronously scrape video data from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the video to scrape.</p> required <p>Returns:</p> Name Type Description <code>Video</code> <code>Video</code> <p>A Video object containing the scraped video data.</p> <p>Raises:</p> Type Description <code>ScraperExecutionError</code> <p>If an error occurs while scraping the video.</p> Source code in <code>youtube_dl_scraper/core/youtube.py</code> <pre><code>def scrape_video(self, url: str) -&gt; Video:\n    \"\"\"\n    Synchronously scrape video data from the given URL.\n\n    Args:\n        url (str): The URL of the video to scrape.\n\n    Returns:\n        Video: A Video object containing the scraped video data.\n\n    Raises:\n        ScraperExecutionError: If an error occurs while scraping the video.\n    \"\"\"\n    try:\n        video_data = self.video_scraper.scrape(url)\n        vid = Video(video_data, self.download_path)\n        vid._get_captions = lambda: self.scrape_captions(url)\n        vid = self.video_scraper.custom_prop(\n            vid, video_data\n        )  # add custom properties\n        return vid\n    except Exception as e:\n        raise ScraperExecutionError(self.video_scraper_name, str(e))\n</code></pre>"},{"location":"reference/site_scrapers/caption_scrapers/__init__/","title":"Reference for <code>youtube_dl_scraper/site_scrapers/caption_scrapers/__init__.py</code>","text":""},{"location":"reference/site_scrapers/caption_scrapers/__init__/#youtube_dl_scraper.site_scrapers.caption_scrapers.register","title":"youtube_dl_scraper.site_scrapers.caption_scrapers.register","text":"<pre><code>register(*scraper_objs)\n</code></pre> <p>Register caption scrapers.</p> Source code in <code>youtube_dl_scraper/site_scrapers/caption_scrapers/__init__.py</code> <pre><code>def register(*scraper_objs):\n    \"\"\"Register caption scrapers.\"\"\"\n    register_scrapers(scrapers, *scraper_objs)\n</code></pre>"},{"location":"reference/site_scrapers/caption_scrapers/downsub/","title":"Reference for <code>youtube_dl_scraper/site_scrapers/caption_scrapers/downsub.py</code>","text":""},{"location":"reference/site_scrapers/caption_scrapers/downsub/#youtube_dl_scraper.site_scrapers.caption_scrapers.downsub.DownSub","title":"youtube_dl_scraper.site_scrapers.caption_scrapers.downsub.DownSub","text":"<pre><code>DownSub(download_path: str)\n</code></pre> <p>               Bases: <code>BaseScraper</code></p> <p>A scraper wrapper for downsub.com</p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def __init__(self, download_path: str):\n    self.download_path = download_path\n</code></pre>"},{"location":"reference/site_scrapers/caption_scrapers/downsub/#youtube_dl_scraper.site_scrapers.caption_scrapers.downsub.DownSub.generate_payload","title":"generate_payload","text":"<pre><code>generate_payload(url: str) -&gt; str\n</code></pre> <p>generate payload to fetch caption endpoint</p> Source code in <code>youtube_dl_scraper/site_scrapers/caption_scrapers/downsub.py</code> <pre><code>def generate_payload(self, url: str) -&gt; str:\n    \"\"\"generate payload to fetch caption endpoint\"\"\"\n    return f\"url = '{url}'\\n\" + payload\n</code></pre>"},{"location":"reference/site_scrapers/caption_scrapers/downsub/#youtube_dl_scraper.site_scrapers.caption_scrapers.downsub.DownSub.parse_caption_data","title":"parse_caption_data","text":"<pre><code>parse_caption_data(data: dict) -&gt; dict\n</code></pre> <p>parse data from the caption endpoint to a general format</p> Source code in <code>youtube_dl_scraper/site_scrapers/caption_scrapers/downsub.py</code> <pre><code>def parse_caption_data(self, data: dict) -&gt; dict:\n    \"\"\"parse data from the caption endpoint to a general format\"\"\"\n    if data.get(\"sourceName\") != \"Youtube\":\n        raise CaptionsNotFoundError(\"Capition found but invalid caption type\")\n    captions_data = {}  # the formatted dictionary for caption data\n    dl_api = data.get(\"urlSubtitle\")\n    captions_data[\"title\"] = data.get(\"title\", \"\")\n    captions_data[\"thumbnail\"] = data.get(\"thumbnail\", \"\")\n    captions_data[\"duration\"] = data.get(\"duration\")\n    captions_data[\"subtitles\"] = []\n    for sub in data.get(\"subtitles\", []):\n        sub[\"code\"] = (\n            \"a.\" + str(find_language(sub[\"name\"]))\n            if \"auto\" in sub[\"code\"]\n            else sub[\"code\"]\n        )\n        captions_data[\"subtitles\"].append(sub)\n    captions_data[\"translations\"] = []\n    for sub in data.get(\"subtitlesAutoTrans\", []):\n        sub[\"code\"] = str(find_language(sub[\"name\"]))  # fetch lang code\n        captions_data[\"translations\"].append(sub)\n    # add more formating to include dowload url for each formart i.e. srt, txt, raw\n    translation_types = (\"subtitles\", \"translations\")\n    for t_type in translation_types:\n        subs = captions_data[t_type]  # subtitle dict\n        for sub in subs:  # for subtitle in subtitles\n            sub[\"urls\"] = {\n                \"raw\": f\"{dl_api}?url={sub['url']}&amp;type=raw&amp;title={captions_data['title']}\",\n                \"txt\": f\"{dl_api}?url={sub['url']}&amp;type=txt&amp;title={captions_data['title']}\",\n                \"srt\": f\"{dl_api}?url={sub['url']}&amp;title={captions_data['title']}\",\n            }\n            sub.pop(\"url\")\n\n    # print(captions_data)\n    return captions_data\n</code></pre>"},{"location":"reference/site_scrapers/caption_scrapers/downsub/#youtube_dl_scraper.site_scrapers.caption_scrapers.downsub.DownSub.process_response","title":"process_response","text":"<pre><code>process_response(caption_endpoint: str) -&gt; dict\n</code></pre> <p>fetch and processes data from the caption endpoint</p> Source code in <code>youtube_dl_scraper/site_scrapers/caption_scrapers/downsub.py</code> <pre><code>def process_response(self, caption_endpoint: str) -&gt; dict:\n    \"\"\"fetch and processes data from the caption endpoint\"\"\"\n    if not caption_endpoint:\n        raise CaptionsNotFoundError(\"Caption endpoint is empty.\")\n    response = requests.get(caption_endpoint)\n    if response.status_code == 200:\n        data = response.json()\n        return self.parse_caption_data(data) if data else None\n    else:\n        raise YouTubeDLScraperError(\n            \"Invalid response code: {}\".format(response.status_code)\n        )\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/__init__/","title":"Reference for <code>youtube_dl_scraper/site_scrapers/video_scrapers/__init__.py</code>","text":""},{"location":"reference/site_scrapers/video_scrapers/__init__/#youtube_dl_scraper.site_scrapers.video_scrapers.register","title":"youtube_dl_scraper.site_scrapers.video_scrapers.register","text":"<pre><code>register(*scraper_objs)\n</code></pre> <p>Register video scrapers</p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/__init__.py</code> <pre><code>def register(*scraper_objs):\n    \"\"\"Register video scrapers\"\"\"\n    register_scrapers(scrapers, *scraper_objs)\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/savetube/","title":"Reference for <code>youtube_dl_scraper/site_scrapers/video_scrapers/savetube.py</code>","text":""},{"location":"reference/site_scrapers/video_scrapers/savetube/#youtube_dl_scraper.site_scrapers.video_scrapers.savetube.SaveTube","title":"youtube_dl_scraper.site_scrapers.video_scrapers.savetube.SaveTube","text":"<pre><code>SaveTube(download_path: str)\n</code></pre> <p>               Bases: <code>BaseScraper</code></p> Source code in <code>youtube_dl_scraper/core/base_scraper.py</code> <pre><code>def __init__(self, download_path: str):\n    self.download_path = download_path\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/y2save/","title":"Reference for <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code>","text":""},{"location":"reference/site_scrapers/video_scrapers/y2save/#youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save","title":"youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save","text":"<pre><code>Y2Save(download_path: str)\n</code></pre> <p>               Bases: <code>BaseScraper</code></p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code> <pre><code>def __init__(self, download_path: str):\n    self.session = requests.Session()\n    self.session.headers.update(self.headers)\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/y2save/#youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save.convert","title":"convert","text":"<pre><code>convert(vid: str, key: str) -&gt; str\n</code></pre> <p>Convert video or audio using the provided vid and key.</p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code> <pre><code>def convert(self, vid: str, key: str) -&gt; str:\n    \"\"\"Convert video or audio using the provided vid and key.\"\"\"\n    csrf_token = self.get_csrf_token()\n    payload = f\"_token={csrf_token}&amp;vid={vid}&amp;key={key}\"\n\n    response = self.session.post(\n        f\"https://{self.__host__}/searchConvert\", data=payload\n    )\n\n    if response.status_code != 200:\n        raise YouTubeDLScraperError(\n            f\"Error occurred during conversion: invalid response code: {response.status_code}\"\n        )\n\n    data = response.json()\n    if data.get(\"status\") != \"ok\":\n        raise ScraperExecutionError(\"Conversion failed\")\n\n    return data[\"dlink\"]\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/y2save/#youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save.get_csrf_token","title":"get_csrf_token","text":"<pre><code>get_csrf_token()\n</code></pre> <p>Fetch CSRF token and cookies from the site.</p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code> <pre><code>def get_csrf_token(self):\n    \"\"\"Fetch CSRF token and cookies from the site.\"\"\"\n    url = f\"https://{self.__host__}/id\"\n    self.session.headers.update({\"User-Agent\": self.ua_generator.random})\n    response = self.session.get(url)\n\n    if response.status_code != 200:\n        raise YouTubeDLScraperError(\n            f\"Error fetching CSRF token: invalid response code: {response.status_code}\"\n        )\n\n    csrf_token = response.text.split('name=\"csrf-token\" content=\"')[1].split('\"')[0]\n    return csrf_token\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/y2save/#youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save.parse_video_data","title":"parse_video_data","text":"<pre><code>parse_video_data(data: dict, url: str) -&gt; dict\n</code></pre> <p>Parse video data into a structured format.</p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code> <pre><code>def parse_video_data(self, data: dict, url: str) -&gt; dict:\n    \"\"\"Parse video data into a structured format.\"\"\"\n    video_data = {\n        \"id\": data[\"vid\"],\n        \"title\": data[\"title\"],\n        \"watch_url\": url,\n        \"thumbnail\": data[\"thumbnail\"],\n        \"duration\": data[\"vduration\"],\n    }\n\n    # Parse stream data\n    streams = {\"video\": [], \"audio\": []}\n\n    # Parse video streams\n    for stream in data[\"convert_links\"].get(\"video\", []):\n        quality = stream[\"quality\"]\n        if quality != \"auto\":\n            cleaned_quality = re.sub(\"p|P\", \"\", quality)\n            quality = int(cleaned_quality or 0) or None\n        else:\n            quality = -1\n        streams[\"video\"].append(\n            {\n                \"quality\": quality,\n                \"label\": stream[\"quality\"].lower(),\n                \"key\": stream[\"key\"],\n                \"args\": [data[\"vid\"], stream[\"key\"]],\n                \"get_url\": (lambda vid, key: self.convert(vid, key)),\n            }\n        )\n\n    # Parse audio streams\n    for stream in data[\"convert_links\"].get(\"audio\", []):\n        streams[\"audio\"].append(\n            {\n                \"quality\": int(stream.get(\"quality\", None).replace(\"kbps\", \"\"))\n                or 0,\n                \"label\": stream[\"quality\"].lower(),\n                \"key\": stream[\"key\"],\n                \"args\": [data[\"vid\"], stream[\"key\"]],\n                \"get_url\": (lambda vid, key: self.convert(vid, key)),\n            }\n        )\n\n    video_data[\"streams\"] = streams\n    return video_data\n</code></pre>"},{"location":"reference/site_scrapers/video_scrapers/y2save/#youtube_dl_scraper.site_scrapers.video_scrapers.y2save.Y2Save.scrape","title":"scrape","text":"<pre><code>scrape(url: str) -&gt; dict\n</code></pre> <p>Scrape video information.</p> Source code in <code>youtube_dl_scraper/site_scrapers/video_scrapers/y2save.py</code> <pre><code>def scrape(self, url: str) -&gt; dict:\n    \"\"\"Scrape video information.\"\"\"\n    csrf_token = self.get_csrf_token()\n    payload = f\"_token={csrf_token}&amp;query={url}\"\n    response = self.session.post(f\"https://{self.__host__}/search\", data=payload)\n\n    if response.status_code != 200:\n        raise YouTubeDLScraperError(\n            f\"Error occurred fetching video data: invalid response code: {response.status_code}\"\n        )\n\n    data = response.json()\n    if data.get(\"status\") != \"ok\":\n        raise VideoNotFoundError(\"No data found for the requested video\")\n\n    return self.parse_video_data(data[\"data\"], url)\n</code></pre>"},{"location":"reference/utils/extract_video_id/","title":"Reference for <code>youtube_dl_scraper/utils/extract_video_id.py</code>","text":""},{"location":"reference/utils/extract_video_id/#youtube_dl_scraper.utils.extract_video_id.extract_video_id","title":"youtube_dl_scraper.utils.extract_video_id.extract_video_id","text":"<pre><code>extract_video_id(url: str) -&gt; Optional[str]\n</code></pre> <p>Extracts video id from toutube video url</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Youtube URL to extract video id from.</p> required <p>Returns:     Optional[str]: Extracted video id or None if URL is invalid.</p> Source code in <code>youtube_dl_scraper/utils/extract_video_id.py</code> <pre><code>def extract_video_id(url: str) -&gt; Optional[str]:\n    \"\"\"\n    Extracts video id from toutube video url\n\n    Args:\n        url (str): Youtube URL to extract video id from.\n    Returns:\n        Optional[str]: Extracted video id or None if URL is invalid.\n    \"\"\"\n    parsed_url = urlparse(url)\n    if parsed_url.hostname in [\"www.youtube.com\", \"youtube.com\"]:\n        if \"/shorts/\" in parsed_url.path:\n            return parsed_url.path.split(\"/shorts/\")[1]\n        query = parse_qs(parsed_url.query)\n        return query.get(\"v\", [None])[0]\n    elif parsed_url.hostname == \"youtu.be\":\n        return parsed_url.path.lstrip(\"/\")\n    return None\n</code></pre>"},{"location":"reference/utils/filename_extractor/","title":"Reference for <code>youtube_dl_scraper/utils/filename_extractor.py</code>","text":""},{"location":"reference/utils/filename_extractor/#youtube_dl_scraper.utils.filename_extractor.get_filename_from_cd","title":"youtube_dl_scraper.utils.filename_extractor.get_filename_from_cd","text":"<pre><code>get_filename_from_cd(cd: str) -&gt; Optional[str]\n</code></pre> <p>Get filename from content-disposition</p> Source code in <code>youtube_dl_scraper/utils/filename_extractor.py</code> <pre><code>def get_filename_from_cd(cd: str) -&gt; Optional[str]:\n    \"\"\"\n    Get filename from content-disposition\n    \"\"\"\n    if not cd:\n        return\n    filename = re.findall(\"filename=(.+)\", cd)\n    if len(filename) == 0:\n        return None\n    return filename[0].replace('\"', \"\").replace(\"\\\\\", \"\")\n</code></pre>"},{"location":"reference/utils/format_time/","title":"Reference for <code>youtube_dl_scraper/utils/format_time.py</code>","text":""},{"location":"reference/utils/format_time/#youtube_dl_scraper.utils.format_time.format_duration","title":"youtube_dl_scraper.utils.format_time.format_duration","text":"<pre><code>format_duration(seconds: int) -&gt; str\n</code></pre> <p>Format a duration in seconds to a human-readable string with hours, minutes, and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>The total duration in seconds.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string representing the duration in the format \"Xh Ym Zs\" or \"Xm Zs\".</p> Source code in <code>youtube_dl_scraper/utils/format_time.py</code> <pre><code>def format_duration(seconds: int) -&gt; str:\n    \"\"\"\n    Format a duration in seconds to a human-readable string with hours, minutes, and seconds.\n\n    Args:\n        seconds (int): The total duration in seconds.\n\n    Returns:\n        str: A formatted string representing the duration in the format \"Xh Ym Zs\" or \"Xm Zs\".\n    \"\"\"\n    hours = seconds // 3600\n    minutes = (seconds % 3600) // 60\n    secs = seconds % 60\n\n    if hours &gt; 0:\n        return f\"{hours}h {minutes}m {secs}s\"\n    elif minutes &gt; 0:\n        return f\"{minutes}m {secs}s\"\n    else:\n        return f\"{secs}s\"\n</code></pre>"},{"location":"reference/utils/format_time/#youtube_dl_scraper.utils.format_time.parse_duration","title":"youtube_dl_scraper.utils.format_time.parse_duration","text":"<pre><code>parse_duration(duration_str: str) -&gt; str\n</code></pre> <p>Parse a duration string in the format of \"HH:MM:SS\" or \"MM:SS\" and return a human-readable duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration_str</code> <code>str</code> <p>A duration string, e.g., \"02:15:30\" or \"15:30\".</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A human-readable string representing the parsed duration, e.g., \"2 hours, 15 minutes, 30 seconds\".</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input duration string is not in a valid format.</p> Source code in <code>youtube_dl_scraper/utils/format_time.py</code> <pre><code>def parse_duration(duration_str: str) -&gt; str:\n    \"\"\"\n    Parse a duration string in the format of \"HH:MM:SS\" or \"MM:SS\" and return a human-readable duration.\n\n    Args:\n        duration_str (str): A duration string, e.g., \"02:15:30\" or \"15:30\".\n\n    Returns:\n        str: A human-readable string representing the parsed duration, e.g., \"2 hours, 15 minutes, 30 seconds\".\n\n    Raises:\n        ValueError: If the input duration string is not in a valid format.\n    \"\"\"\n    parts = list(map(int, duration_str.split(\":\")))\n    if len(parts) == 3:\n        hours, minutes, seconds = parts\n    elif len(parts) == 2:\n        hours = 0\n        minutes, seconds = parts\n    else:\n        raise ValueError(\"Invalid duration format\")\n\n    result = []\n    if hours &gt; 0:\n        result.append(f\"{hours} hour{'s' if hours &gt; 1 else ''}\")\n    if minutes &gt; 0:\n        result.append(f\"{minutes} minute{'s' if minutes &gt; 1 else ''}\")\n    if seconds &gt; 0:\n        result.append(f\"{seconds} second{'s' if seconds &gt; 1 else ''}\")\n\n    return \", \".join(result)\n</code></pre>"},{"location":"reference/utils/format_time/#youtube_dl_scraper.utils.format_time.format_timedelta","title":"youtube_dl_scraper.utils.format_time.format_timedelta","text":"<pre><code>format_timedelta(seconds: int) -&gt; str\n</code></pre> <p>Convert a duration in seconds to a string representation of a timedelta.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>The total duration in seconds.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the timedelta, e.g., \"1:15:30\".</p> Source code in <code>youtube_dl_scraper/utils/format_time.py</code> <pre><code>def format_timedelta(seconds: int) -&gt; str:\n    \"\"\"\n    Convert a duration in seconds to a string representation of a timedelta.\n\n    Args:\n        seconds (int): The total duration in seconds.\n\n    Returns:\n        str: A string representation of the timedelta, e.g., \"1:15:30\".\n    \"\"\"\n    td = timedelta(seconds=seconds)\n    return str(td)\n</code></pre>"},{"location":"reference/utils/playwright_runner/","title":"Reference for <code>youtube_dl_scraper/utils/playwright_runner.py</code>","text":""},{"location":"reference/utils/playwright_runner/#youtube_dl_scraper.utils.playwright_runner.Playwright","title":"youtube_dl_scraper.utils.playwright_runner.Playwright","text":"<p>A class that interacts with the Playwright service to execute code remotely.</p> <p>Attributes:</p> Name Type Description <code>available_languages</code> <code>list</code> <p>A list of supported programming languages for remote code execution.</p> <code>server</code> <code>str</code> <p>The URL endpoint for the Playwright service.</p>"},{"location":"reference/utils/playwright_runner/#youtube_dl_scraper.utils.playwright_runner.Playwright.run","title":"run  <code>staticmethod</code>","text":"<pre><code>run(code: str, language: str = 'python') -&gt; Dict[str, Optional[str]]\n</code></pre> <p>Executes a code snippet remotely using Playwright's cloud service.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to be executed remotely.</p> required <code>language</code> <code>str</code> <p>The programming language in which the code is written. Default is \"python\".</p> <code>'python'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Optional[str]]</code> <p>A dictionary containing the execution result with keys such as <code>status_code</code>,   <code>success</code>, <code>error</code>, and <code>output</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided language is not supported.</p> <code>PlaywrightError</code> <p>If an error occurs during the HTTP request or code execution.</p> Source code in <code>youtube_dl_scraper/utils/playwright_runner.py</code> <pre><code>@staticmethod\ndef run(code: str, language: str = \"python\") -&gt; Dict[str, Optional[str]]:\n    \"\"\"\n    Executes a code snippet remotely using Playwright's cloud service.\n\n    Args:\n        code (str): The code to be executed remotely.\n        language (str): The programming language in which the code is written. Default is \"python\".\n\n    Returns:\n        dict: A dictionary containing the execution result with keys such as `status_code`,\n              `success`, `error`, and `output`.\n\n    Raises:\n        ValueError: If the provided language is not supported.\n        PlaywrightError: If an error occurs during the HTTP request or code execution.\n    \"\"\"\n\n    if language.lower() not in Playwright.available_languages:\n        raise ValueError(\n            f\"Language not supported. Supported languages are {Playwright.available_languages}\"\n        )\n\n    headers = {\n        \"authority\": \"try.playwright.tech\",\n        \"accept\": \"*/*\",\n        \"content-type\": \"application/json\",\n        \"origin\": \"https://try.playwright.tech\",\n        \"referer\": f\"https://try.playwright.tech/?l={language.lower() if language else 'playwright-test'}\",\n        \"user-agent\": \"Postify/1.0.0\",\n    }\n\n    # Prepare the payload for the POST request\n    data = {\"code\": code, \"language\": language}\n    session = requests.Session()\n    retries = Retry(\n        total=3, backoff_factor=1, status_forcelist=[500, 502, 503, 504]\n    )\n    session.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\n    try:\n        response = session.post(Playwright.server, headers=headers, json=data)\n        response.raise_for_status()\n        out = response.json()\n        out[\"status_code\"] = response.status_code\n        return out\n    except requests.exceptions.HTTPError as err:\n        print(f\"HTTP error occurred: {err}\")\n        data = response.json()\n        raise PlaywrightError(\n            f\"HTTP error occurred: {err}\",\n            response.status_code,\n            data.get(\"success\", \"\"),\n            data.get(\"error\", \"\"),\n            data.get(\"output\", \"\"),\n        )\n    except ValueError as e:\n        print(\"Failed to decode JSON response.\")\n        raise PlaywrightError(repr(e))\n</code></pre>"},{"location":"reference/utils/registration/","title":"Reference for <code>youtube_dl_scraper/utils/registration.py</code>","text":""},{"location":"reference/utils/registration/#youtube_dl_scraper.utils.registration.register_scrapers","title":"youtube_dl_scraper.utils.registration.register_scrapers","text":"<pre><code>register_scrapers(scrapers_dict, *scraper_objs)\n</code></pre> <p>Register scrapers in the provided dictionary</p> Source code in <code>youtube_dl_scraper/utils/registration.py</code> <pre><code>def register_scrapers(scrapers_dict, *scraper_objs):\n    \"\"\"Register scrapers in the provided dictionary\"\"\"\n    for scraper in scraper_objs:\n        if issubclass(scraper, BaseScraper):\n            scrapers_dict[scraper.__name__.lower()] = scraper\n</code></pre>"},{"location":"reference/utils/title_to_slug/","title":"Reference for <code>youtube_dl_scraper/utils/title_to_slug.py</code>","text":""},{"location":"reference/utils/title_to_slug/#youtube_dl_scraper.utils.title_to_slug.title_to_slug","title":"youtube_dl_scraper.utils.title_to_slug.title_to_slug","text":"<pre><code>title_to_slug(title: str) -&gt; str\n</code></pre> <p>Converts a YouTube video title into a URL-friendly slug.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The YouTube video title.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A slug suitable for use in URLs.</p> Source code in <code>youtube_dl_scraper/utils/title_to_slug.py</code> <pre><code>def title_to_slug(title: str) -&gt; str:\n    \"\"\"\n    Converts a YouTube video title into a URL-friendly slug.\n\n    Args:\n        title (str): The YouTube video title.\n\n    Returns:\n        str: A slug suitable for use in URLs.\n    \"\"\"\n    # Remove non-ASCII characters and accents\n    title = unidecode(title)\n    title = title.lower()\n    title = re.sub(r\"[^a-z0-9]+\", \"-\", title)\n    title = title.strip(\"-\")\n\n    return title\n</code></pre>"},{"location":"tutorials/downloading-a-video/","title":"Downloading a Video","text":"<p>The YouTube DL Scraper allows you to scrape and download videos from multiple YouTube downloader websites. This guide demonstrates how to download a video using the scraper.</p> <p>Import the YouTube Classe</p> <p>To begin, import the necessary classes from the package:</p> <pre><code>from youtube_dl_scraper import YouTube\n</code></pre> Alternatively <p>You cam import the YouTube class in other ways</p> from corefrom the youtube moudle <pre><code>from youtube_dl_scraper.core import YouTube\n</code></pre> <pre><code>from youtube_dl_scraper.core.youtube import YouTube\n</code></pre> <p>Next intilize the YouTube Object</p> <pre><code>youtube = YouTube()\n</code></pre> Tip <p>You can select the scrapers to use:</p> video scrapercaption scraper <p>You can select the video <code>scraper</code> to use by using the <code>video_scraper_name</code><sup>1</sup> argument <pre><code>youtube = YouTube(video_scraper_name=\"y2save\")\n</code></pre></p> <p>You can select the caption <code>scraper</code> to use by using the <code>caption_scraper_name</code><sup>2</sup> argument <pre><code>youtube = YouTube(caption_scraper_name=\"downsub\")\n</code></pre></p> <p>Now lets download a video for this example we'll download: Coding levels explaind by thedevgeniusyt .</p> <pre><code>video = youtube.scrape_video('https://youtu.be/dhlx4hGmgPY?si=3LOCbAqotNz3w0Ab')\n</code></pre> <p>Now we have a Video Object which contains video data This makes it easy for us to get the video infomation like title, duration e.t.c</p> <pre><code>print(video.title) # (1)!\nprint(video.duration) # (2)!\nprint(video.fduration) # (3)!\nprint(video.thumbnail) # (4)!\n</code></pre> <ol> <li>Output: <code>'coding levels explained:what makes a beginner, intermediate and expert programmer?'</code></li> <li>Output: <code>185</code></li> <li>Output: <code>'3.08 min'</code></li> <li>Output: <code>python 'https://i.ytimg.com/vi/dhlx4hGmgPY/sddefault.jpg'</code></li> </ol> <p>And to download the highest quality video</p> <pre><code># This returns the downloaded file path\nprint(video.get_highest_resolution().download()) # (1)!\n</code></pre> <ol> <li>Output: <code>'coding-levels-explained-what-makes-a-beginner-interm... .mp4'</code></li> </ol> <ol> <li> <p>The curretly avaliable video scrapers are SaveTube and Y2Save.\u00a0\u21a9</p> </li> <li> <p>The only curretly avaliable caption scraper is DownSub.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/format-and-codec-conversion/","title":"Format and Codec Conversion","text":"<p>In this tutorial we'll deal with convertion of codecs<sup>1</sup> and formats. Lets start with this Youtube video by Arjan Codes.</p> codec_demo.py<pre><code>from youtube_dl_scraper import YouTube\nyoutube = YouTube()\nvideo = youtube.scrape_video(\"https://youtu.be/0DWx7VQHkRY?si=2dGCBJowS_JCgEn2\")\nvideo_file = video.streams.filter(resolution_value=360).first().download()\n</code></pre> <p>Info</p> <p>YouTube DL Scraper allows for converting codecs<sup>1</sup> and formats using the <code>Converter</code> module at <code>youtube_dl_scraper.converter</code>.</p> <p>Now that we've downloaded our video, we can now convert it or change the format.</p>"},{"location":"tutorials/format-and-codec-conversion/#changing-codec-of-video","title":"Changing Codec of video","text":"<p>To change the codec<sup>1</sup> of a video is pretty simple, to do that well use our <code>VideoConverter</code> class from our converter module.</p> <p>Example</p> converting video codec<pre><code>from youtube_dl_scraper.converter import VideoConverter\nconverter = VideoConverter(\n    input_path=video_file,\n    output_path=\".\", # (1)!\n    video_codec=\"h264\"\n)\nprint(converter.convert()) # returns path to output_file\n</code></pre> <ol> <li>if the <code>output_path</code> argument is set to <code>'.'</code> the <code>output_file</code> will be saved at the <code>input_file</code> directory.</li> </ol> <p>Output: <pre><code>downloads/this-is-way-more-dangerous-than-ai-360p-30fps-converted.mp4\n</code></pre> if you'd like to change the video format(ext) all you'll have to do is set the <code>output_path</code> to a new path with the preffered extention for example <code>'downloads/converted.m4a'</code>.</p> <p>You can also change the video audio codec<sup>1</sup> because some videos contaons audio .</p> <p>Example</p> <p><pre><code>converter = VideoConverter(\n    input_path=video_file,\n    output_path=\"downloads/video_with_opus_audio_codec.mp4\",\n    video_codec=\"h264\",\n    audio_codec=\"opus\"\n)\nprint(converter.convert())\n</code></pre> Output: <pre><code>downloads/video_with_opus_audio_codec.mp4\n</code></pre></p>"},{"location":"tutorials/format-and-codec-conversion/#changing-codec-of-audio","title":"Changing Codec of Audio","text":"<p>Changing the codec<sup>1</sup> of an audio file is simillar to that of a video file, the only diffrence is the fact that we use the <code>AudioConverter</code> class instead.</p> <pre><code>audio_file = video.streams.get_highest_bitrate().download()\n</code></pre> <p>Example</p> converting video codec<pre><code>from youtube_dl_scraper.converter import AudioConverter\nconverter = AudioConverter(\n    input_path=audio_file,\n    output_path=\".\", # (1)!\n    audio_codec=\"opus\" # or libopus\n)\nprint(converter.convert()) # returns path to output_file\n</code></pre> <ol> <li>if the <code>output_path</code> argument is set to <code>'.'</code> the <code>output_file</code> will be saved at the <code>input_file</code> directory.</li> </ol> <p>Output: <pre><code>downloads/this-is-way-more-dangerous-than-ai-320kbps-audio-converted.m4a\n</code></pre></p> <p>But the <code>AudioConverter</code> allows us to adjust the audio bitrate.</p> <p>Example</p> <p><pre><code>converter = AudioConverter(\n    input_path=audio_file,\n    output_path=\"downloads/audio_at_320kbps.mp3\",\n    audio_codec=\"opus\", # or libopus\n    bitrate=\"320k\"\n)\nprint(converter.convert())\n</code></pre> Output: <pre><code>downloads/audio_at_320kbps.mp3\n</code></pre></p> <p>Tip</p> <p>You can also use the AudioConverter to convert a video to an audio file. video to audio<pre><code>converter = AudioConverter(\n    input_path=video_file,\n    output_path=\"downloads/video_to_audio.m4a\"\n    audio_codec=\"aac\"\n)\nprint(converter.convert())\n</code></pre> Output: <pre><code>downloads/video_to_audio.m4a\n</code></pre></p> <p>For more info about the AudioConverter visit the api refrence of youtube_dl_scraper.converter.video_converter.VideoConverter.</p> <ol> <li> <p>A codec is a tool that compresses and decompresses video or audio files. It reduces file size while maintaining quality. Common video codecs include H.264 and VP9, and audio codecs like AAC and MP3. Codecs help ensure media compatibility across devices.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial/","title":"Tutorials","text":"<p>Welcome to the tutorials section of the YouTube DL Scraper documentation. This guide will walk you through common use cases, showcasing how to leverage the power of our package to scrape video, audio, and captions from various YouTube downloader websites.</p> <ul> <li> <p> Downlaoding a video</p> <p>Use <code>youtube-dl-scraper</code> to download your first video in minutes.</p> <p> Download your first video</p> </li> <li> <p> Working with Streams</p> <p>Learn about <code>Streams</code> and <code>StreamArrays</code></p> <p> Learn More</p> </li> <li> <p> Working with Captions</p> <p>Learn about <code>Captions</code> and <code>CaptionArrays</code>, how to fetch captions.</p> <p> Learn More</p> </li> <li> <p> Format and Codec Conversion</p> <p>Learn about <code>converters</code>, how to chage formats and codecs of videos/audios.</p> <p> Learn More</p> </li> </ul> <p>We hope these tutorials help you get started with the YouTube DL Scraper package. If you need further assistance, feel free to check out the API Reference for more in-depth explanations.</p>"},{"location":"tutorials/working-with-captions-captionarray/","title":"Working With Captions and CaptionArray","text":"<p>The Caption class represents a single caption with its metadata, such as language, and format. The CaptionArray class provides a collection of Caption objects, offering methods to manage and interact with multiple captions easily.</p> <p>With these tools, you can:</p> <ul> <li> <p>Extract captions in various languages and formats (e.g., SRT, TXT).</p> </li> <li> <p>Download and save captions for offline use.</p> </li> </ul> <p>Example</p> <p>caption_demo.py<pre><code>from youtube_dl_scraper import YouTube\nyoutube = YouTube()\ncaptions = youtube.scrape_captions(\"https://youtu.be/sF9xYtouZjY?si=z6ZWk4raQeHgQDz\")\nprint(captions)\nprint(captions.subtitles)\n</code></pre> The <code>scrape_caption</code> method returns a CaptionArray object. output<pre><code>&lt;youtube_dl_scraper.core.caption_array.CaptionArray object at 0xe60527e0&gt;\n({'name': 'English (auto-generated)', 'code': 'a.en'},\n{'name': 'English (United States)', 'code': 'en-US'},\n{'name': 'Portuguese', 'code': 'pt'},\n{'name': 'Spanish', 'code': 'es'})\n</code></pre></p> <p>These features make it seamless to access and utilize YouTube captions efficiently.</p> Tip <p>You can also fetch the captions from the video object. <pre><code>from youtube_dl_scraper import YouTube\n\nyoutube = YouTube()\nvideo = youtube.scrape_video(\"https://youtu.be/sF9xYtouZjY?si=z6ZWk4raQeHgQDz\")\ncaptions = video.captions\n</code></pre></p>"},{"location":"tutorials/working-with-captions-captionarray/#fetching-a-specific-caption","title":"Fetching a Specific Caption","text":"<p>The CaptionArray object has methods that makes it easy to fetch a caption of a specfic language or langcode<sup>1</sup></p> Difference between normal and translated captions <p>There are two types of captions Normal and Translated. Which can be determined using the <code>translated</code> attribit from the Caption object. a normal caption is on written by the user or is auto generated by youtube while a translated caption is one translated by AI. normal captions<pre><code>&gt;&gt;&gt; print(captions.subtitles)\n({'name': 'English (auto-generated)', 'code': 'a.en'},\n{'name': 'English (United States)', 'code': 'en-US'},\n{'name': 'Portuguese', 'code': 'pt'},\n{'name': 'Spanish', 'code': 'es'})\n</code></pre></p> translated captions<pre><code>&gt;&gt;&gt; print(captions.translations)\n({'name': 'Abkhaz', 'code': 'ab'},\n{'name': 'Afar', 'code': 'aa'},\n{'name': 'Afrikaans', 'code': 'af'},\n{'name': 'Akan', 'code': 'ak'},\n{'name': 'Albanian', 'code': 'sq'},\n{'name': 'Amharic', 'code': 'am'},\n{'name': 'Arabic', 'code': 'ar'},\n...\n{'name': 'Zulu', 'code': 'zu'})\n</code></pre>"},{"location":"tutorials/working-with-captions-captionarray/#fetching-caption-by-language-name","title":"Fetching Caption by Language Name","text":"<p>To get a caption by <code>langname</code> we use the <code>get_captions_by_name</code> method.</p> Note <p>The <code>get_captions_by_name</code> method only returns normal Captions. Read more from the api refrence of youtube_dl_scraper.core.caption_array.CaptionArray.</p> <p>Example</p> <p><pre><code>print(captions.get_captions_by_name('Spanish'))\n</code></pre> Output: <pre><code>[&lt;caption.Caption object lang_code: es translated: False&gt;]\n</code></pre></p> <p>You can also fetch a translated caption by <code>langname</code> using the <code>get_translated_captions_by_name()</code> method.</p> Note <p>The <code>get_translated_captions_by_name()</code> method only return translated Captions. Read more from the api refrence of youtube_dl_scraper.core.caption_array.CaptionArray.</p> <p>Example</p> <p><pre><code>print(captions.get_translated_captions_by_name('french'))\n</code></pre> Output: <pre><code>[&lt;caption.Caption object lang_code: fr translated: True&gt;,\n&lt;caption.Caption object lang_code: crs translated: True&gt;]\n</code></pre></p>"},{"location":"tutorials/working-with-captions-captionarray/#fetching-caption-by-language-code","title":"Fetching Caption by Language Code","text":"<p>To get a caption by <code>langname</code>, we use the <code>get_captions_by_lang_code</code> method.</p> <p>Example</p> <p><pre><code>print(captions.get_captions_by_lang_code('es'))\n</code></pre> Output: <pre><code>&lt;caption.Caption object lang_code: es translated: False&gt;\n</code></pre></p> <p>You can also fetch a translated caption by <code>langname</code> using the <code>get_translated_captions_by_lang_code()</code> method.</p> <p>Example</p> <p><pre><code>print(captions.get_translated_captions_by_lang_code('fr'))\n</code></pre> Output: <pre><code>&lt;caption.Caption object lang_code: fr translated: True&gt;\n</code></pre></p>"},{"location":"tutorials/working-with-captions-captionarray/#dowloading-captions","title":"Dowloading Captions","text":"<p>Now, that you've gotten the specfic Caption you want, now you can read, save it in different formats.</p> <p>The Caption object has diffrent methods and attributes to allow this.</p> <p>Example</p> <p><pre><code>caption = captions.get_captions_by_lang_code('es') # fetching spanish caption\nprint(caption.raw) # fetching caption text\nprint(caption.txt()) # fetching caption in text format\nprint(caption.srt()) # fetching caption in srt format\n</code></pre> Output: <pre><code>1\n00:00:00,060 --&gt; 00:00:04,219\nHace seis a\u00f1os, Tesla baj\u00f3 una sorpresa de la parte trasera de un cami\u00f3n.\n\n2\n00:00:04,260 --&gt; 00:00:13,380\nSe trataba del Roadster 2.0, un auto superdeportivo el\u00e9ctrico de dos puertas con especificaciones incre\u00edbles y el r\u00e9cord de aceleraci\u00f3n mundial.\n\n3\n00:00:13,420 --&gt; 00:00:17,590\nSe supon\u00eda que ese ser\u00eda el auto que acabar\u00eda con todos los otros autos a combustible.\n...\n137\n00:12:19,240 --&gt; 00:12:19,775\nAdi\u00f3s.\n/storage/emulated/0/Youtube-dl-scraper/Youtube-dl-scraper/downloads/Driving The New Fastest Car Ever Made!.txt\n/storage/emulated/0/Youtube-dl-scraper/Youtube-dl-scraper/downloads/Driving The New Fastest Car Ever Made!.srt\n</code></pre></p> <ol> <li> <p>Language codes are standardized short identifiers, like en or fr, used to represent languages and their regional or script variants for localization and data interchange.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/working-with-streams-and-streamarrays/","title":"Working With Streams and StreamArrays","text":"<p>The Stream and StreamArray classes are core components of the <code>youtube_dl_scraper</code> package, enabling easy access and manipulation of video and audio streams. These classes provide a clean interface to work with individual streams or groups of streams.</p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#stream","title":"Stream","text":"<p>The Stream class represents a single video or audio stream. It provides detailed information about the stream and includes methods for further interaction.</p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#streamarray","title":"StreamArray","text":"<p>The StreamArray class represents a collection of Stream objects. It includes utility methods for filtering and selecting streams based on specific criteria.</p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#key-features","title":"Key Features","text":"<ul> <li>Retrieve all streams matching a specific quality or format.</li> <li>Iterate over all available streams.</li> <li>And much more.</li> </ul> <p>These classes streamline the process of managing YouTube  video/audio streams, making it easy to access and utilize downloadable media. For more advanced use cases, explore the methods and attributes available within the Stream and StreamArray classes.</p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#working-with-streams","title":"Working with Streams","text":"<p>We'll begin with the video object from the previous example stored in the <code>video</code> variable.</p> Read more <p>From the previous example.</p> example.py<pre><code>from youtube_dl_scraper import YouTube\nyoutube = YouTube()\nvideo = youtube.scrape_video('https://youtu.be/sF9xYtouZjY?si=z6ZWk4raQeHgQDz')\n\nprint(video.title) # print video title\n</code></pre> <p>We'll beging by running the following to list all streams.</p> <pre><code># ...\nprint(video.streams) # (1)!\n</code></pre> <ol> <li>this returns the StreamArray object containing the available streams in the video.</li> </ol> output <pre><code>((video 1080p 30fps is_hdr=False has_audio=True),\n(video 720p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(audio 320), (audio 192),\n(video 144p 30fps is_hdr=False has_audio=True),\n(audio 128), (audio 64), (audio 32))\n</code></pre>"},{"location":"tutorials/working-with-streams-and-streamarrays/#filtering-streams","title":"Filtering Streams","text":"<p>YouTube DL Scraper provides built-in functionality to filter streams available in a StreamArray object using the <code>filter()</code> method. This method supports various keyword arguments, allowing you to customize your search. Below, we\u2019ll review some of the most commonly used options. For a complete list of filterable properties, refer to the API documentation for youtube_dl_scraper.core.stream_array.StreamArray.filter.</p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#filtering-video-streams","title":"Filtering Video Streams","text":"<p>To filter video streams we use the <code>get_video_streams()</code> method.</p> <pre><code>print(video.streams.get_video_streams())\n</code></pre> output <pre><code>((video 1080p 30fps is_hdr=False has_audio=True),\n(video 720p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(video 144p 30fps is_hdr=False has_audio=True))\n</code></pre> more on video streams <p>Not all streams has audio, streams without audio are called DASH streams while ones with audio are Progressive streams. To filter video streams to ones with or without audio we use the <code>filter()</code> method. <pre><code>print(video.streams.get_video_streams().filter(has_audio=True)) # with audio\nprint(video.streams.get_video_streams().filter(has_audio=False)) # without audio\n</code></pre> Output: <pre><code>((video 1080p 30fps is_hdr=False has_audio=True),\n(video 720p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(video 360p 30fps is_hdr=False has_audio=True),\n(video 144p 30fps is_hdr=False has_audio=True))\n()\n</code></pre></p>"},{"location":"tutorials/working-with-streams-and-streamarrays/#filtering-audio-streams","title":"Filtering Audio Streams","text":"<p>To filter video streams we use the <code>get_audio_streams()</code> method.</p> <pre><code>print(video.streams.get_audio_streams())\n</code></pre> output <pre><code>((audio 320), (audio 192), (audio 128),\n(audio 64), (audio 32))\n</code></pre>"},{"location":"tutorials/working-with-streams-and-streamarrays/#ordering-streams","title":"Ordering Streams","text":"<p>YouTube DL Scraper support the ability to order streams by any of it's attributes using the <code>order_by()</code> method.</p> <pre><code>print(video.streams.get_audio_streams().order_by(\"abr\")) # (1)!\n</code></pre> <ol> <li>this returns a new StreamArray object with streams ordered by abr</li> </ol> output <pre><code>((audio 320), (audio 192), (audio 128), (audio 64), (audio 32))\n</code></pre>"},{"location":"tutorials/working-with-streams-and-streamarrays/#downloading-streams","title":"Downloading Streams","text":"<p>After you\u2019ve selected the Stream you\u2019re interested, you\u2019re ready to interact with it. At this point, you can query information about the stream, such as its size, whether the stream is audio/video, and more. You can also use the download method to save the file.</p> <pre><code>print(video.streams.filter(resolution_value=720).download())\n</code></pre> Tip <p>You can use <code>first()</code> and <code>last()</code> method to select the first or last Stream in the StreamArray. <pre><code>print(video.streams.first())\nprint(video.streams.get_video_streams().last())\n</code></pre> And you can get the available qualities in a stream array using the <code>available_qualities</code> property. <pre><code>print(video.streams.available_qualities) # (1)!\n</code></pre></p> <ol> <li>Output: <code>{'video': (1080, 720, 360, 360, 144), 'audio': (320, 192, 128, 64, 32)}</code></li> </ol> <p>Lastly you can fetch streams using their index. <pre><code>print(video.streams[0]) # getting first stream\n</code></pre></p> <p>You can read more from the api docs for youtube_dl_scraper.core.stream_array.StreamArray</p>"}]}